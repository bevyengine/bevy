# B0002

To keep [Rust rules on references] (either one mutable reference or any number of immutable references) on a resource,
it is not possible to have more than one resource of a kind if one is mutable in the same system.
This can happen between [`Res<T>`] and [`ResMut<T>`] for the same `T`
or between [`NonSend<T>`] and [`NonSendMut<T>`] for the same `T`.

Erroneous code example:

```rust should_panic
use bevy::prelude::*;

fn update_materials(
    mut material_updater: ResMut<Assets<StandardMaterial>>,
    current_materials: Res<Assets<StandardMaterial>>,
) {
    // ...
}

fn main() {
    App::new()
        .add_plugins(DefaultPlugins)
        .add_systems(Update, update_materials)
        .run();
}
```

This will panic, as it's not possible to have both a mutable and an
immutable resource on `Assets<StandardMaterial>` at the same time.

As a mutable resource already provides access to the current
resource value, so you can remove the immutable resource.

```rust no_run
use bevy::prelude::*;

fn update_materials(
    mut material_updater: ResMut<Assets<StandardMaterial>>,
) {
    // ...
}

fn main() {
    App::new()
        .add_plugins(DefaultPlugins)
        .add_systems(Update, update_materials)
        .run();
}
```

[Rust rules on references]: <https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html#the-rules-of-references>
[`Res<T>`]: <https://docs.rs/bevy/*/bevy/ecs/system/struct.Res.html>
[`ResMut<T>`]: <https://docs.rs/bevy/*/bevy/ecs/system/struct.ResMut.html>
[`NonSend<T>`]: <https://docs.rs/bevy/*/bevy/ecs/system/struct.NonSend.html>
[`NonSendMut<T>`]: <https://docs.rs/bevy/*/bevy/ecs/system/struct.NonSendMut.html>

use std::mem::size_of;

use bevy_ptr::{Ptr, PtrMut, ThinSlicePtr, UnsafeCellDeref};
use bevy_utils::all_tuples;

use crate::{
    archetype::Archetype,
    change_detection::{Mut, MutUntyped, Ticks, TicksMut},
    component::{ComponentId, ComponentStorage, StorageType, Tick},
    entity::Entity,
    prelude::{AnyOf, Component, EntityMut, EntityRef, Has, Ref, World},
    query::DebugCheckedUnwrap,
    storage::{Table, TableRow},
    world::unsafe_world_cell::UnsafeWorldCell,
};

use super::{ComponentPtr, ComponentState, Term, TermAccess, TermFilter, TermState};

/// Types that can be fetched from a [`World`] using a [`TermQuery`](crate::prelude::TermQuery).
///
/// This is implemented for all the same types as [`WorldQuery`](crate::query::WorldQuery) as well
/// as additional types that for dynamic queries.
///
/// Theses additional types are [`Ptr`] and [`PtrMut`] which are equivalent to
/// &T and &mut T respectively but their component id is set at runtime.
///
/// ```
/// use bevy_ecs::prelude::*;
/// use bevy_ptr::Ptr;
///
/// #[derive(Component)]
/// struct MyComponent;
///
/// let mut world = World::new();
/// world.spawn(MyComponent);
///
/// let component_id = world.init_component::<MyComponent>();
///
/// let mut query = unsafe {
///     QueryBuilder::<(Entity, Ptr)>::new(&mut world)
///         .set_dynamic_by_id(1, component_id)
///         .build()
/// };
///
/// let (entity, component): (Entity, Ptr) = query.single(&world);
/// let component_ref: &MyComponent = unsafe { component.deref::<MyComponent>() };
/// ```
///
/// # Safety
///
/// Component access of `Self::ReadOnly` must be a subset of `Self`
/// and `Self::ReadOnly` must match exactly the same archetypes/tables as `Self`
///
/// Implementor must ensure that [`Self::from_fetch`] is safe to call on a [`FetchedTerm`]
/// resolved from the value returned by [`Self::init_term`]
pub trait QueryFetch {
    /// The item returned by this [`QueryFetch`]
    type Item<'w>;
    /// The read-only variant of this [`QueryFetch`]
    type ReadOnly: QueryFetch;

    /// True if all components accessed by this are [`StorageType::Table`]
    const DENSE: bool;

    /// Creates a new [`Term`] instance satisfying the requirements for [`Self::init_term_state`]
    fn init_term(world: &mut World, term: Term) -> Term;

    /// Creates a new [`TermState`] instance satisfying the requirements for [`Self::fetch_term`]
    ///
    /// # Safety
    ///
    /// - `term` must contain the terms instantiated by [`Self::init_terms`]
    unsafe fn init_term_state<'w>(_world: UnsafeWorldCell<'w>, _term: &Term) -> TermState<'w>;

    /// Adjusts internal state to account for the next [`Table`].
    ///
    /// # Safety
    ///
    /// - `table` must contain the components accessed by `state`
    #[inline(always)]
    unsafe fn set_term_table<'w>(state: &mut TermState<'w>, _table: &'w Table) {
        state.matches = true;
    }

    /// Adjusts internal state to account for the next [`Archetype`].
    ///
    /// # Safety
    ///
    /// - `table` and `archetype` must contain the components accessed by `state`
    #[inline(always)]
    unsafe fn set_term_archetype<'w>(
        state: &mut TermState<'w>,
        _archetype: &'w Archetype,
        table: &'w Table,
    ) {
        Self::set_term_table(state, table);
    }

    /// Fetch the [`Self::Item`] for the given entity at the given table row
    ///
    /// # Safety
    ///
    /// - `state` must be fetchable to `Self::Item`
    unsafe fn filter_term<'w>(
        _world: UnsafeWorldCell<'w>,
        _last_run: Tick,
        _this_run: Tick,
        _state: &TermState<'w>,
        _entity: Entity,
        _row: TableRow,
    ) -> bool {
        true
    }

    /// Fetch the [`Self::Item`] for the given entity at the given table row
    ///
    /// # Safety
    ///
    /// - `state` must be fetchable to `Self::Item`
    unsafe fn fetch_term<'w>(
        world: UnsafeWorldCell<'w>,
        last_run: Tick,
        this_run: Tick,
        state: &TermState<'w>,
        entity: Entity,
        row: TableRow,
    ) -> Self::Item<'w>;

    /// Returns `true` if this query matches a set of components. Otherwise, returns `false`.'
    ///
    /// # Safety
    ///
    /// - `state` must be generated by [`Self::init_term_state`]
    unsafe fn matches_component_set(
        state: &TermState<'_>,
        set_contains_id: &impl Fn(ComponentId) -> bool,
    ) -> bool;

    /// Returns `true` if this query matches a set of components. Otherwise, returns `false`.'
    ///
    /// # Safety
    ///
    /// - `state` must be generated by [`Self::init_term_state`]
    unsafe fn set_matches_state(
        state: &mut TermState<'_>,
        set_contains_id: &impl Fn(ComponentId) -> bool,
    ) -> bool {
        state.matches = Self::matches_component_set(state, set_contains_id);
        state.matches
    }
}

/// Types that can be fetched from a [`World`] using a [`TermQuery`](crate::prelude::TermQuery).
///
/// This is implemented for all the same types as [`WorldQuery`](crate::query::WorldQuery) as well
/// as additional types that for dynamic queries.
///
/// Theses additional types are [`Ptr`] and [`PtrMut`] which are equivalent to
/// &T and &mut T respectively but their component id is set at runtime.
///
/// ```
/// use bevy_ecs::prelude::*;
/// use bevy_ptr::Ptr;
///
/// #[derive(Component)]
/// struct MyComponent;
///
/// let mut world = World::new();
/// world.spawn(MyComponent);
///
/// let component_id = world.init_component::<MyComponent>();
///
/// let mut query = unsafe {
///     QueryBuilder::<(Entity, Ptr)>::new(&mut world)
///         .set_dynamic_by_id(1, component_id)
///         .build()
/// };
///
/// let (entity, component): (Entity, Ptr) = query.single(&world);
/// let component_ref: &MyComponent = unsafe { component.deref::<MyComponent>() };
/// ```
pub trait QueryFetchGroup {
    /// The item returned by this [`QueryFetch`]
    type Item<'w>;
    /// The read-only variant of this [`QueryFetch`]
    type ReadOnly: QueryFetchGroup;

    /// True if all components accessed by this are [`StorageType::Table`]
    const DENSE: bool;
    /// Number of terms that make up this group
    const SIZE: usize;

    /// Creates a new [`Term`] instance satisfying the requirements for [`Self::init_term_states`]
    fn init_terms(world: &mut World, terms: &mut Vec<Term>, depth: u8);

    /// Creates a new [`TermState`] instance satisfying the requirements for [`Self::fetch_terms`]
    ///     
    /// # Safety
    ///
    /// - `term` must contain the terms instantiated by [`Self::init_terms`]
    unsafe fn init_term_states<'w>(
        world: UnsafeWorldCell<'w>,
        term: ThinSlicePtr<'_, Term>,
        state: &mut Vec<TermState<'w>>,
    );

    /// Adjusts internal state to account for the next [`Table`].
    ///
    /// # Safety
    ///
    /// - `table` must contain the components accessed by `state`
    unsafe fn set_term_tables<'w>(state: ThinSlicePtr<'_, TermState<'w>>, table: &'w Table);

    /// Adjusts internal state to account for the next [`Archetype`].
    ///
    /// # Safety
    ///
    /// - `table` and `archetype` must contain the components accessed by `state`
    unsafe fn set_term_archetypes<'w>(
        state: ThinSlicePtr<'_, TermState<'w>>,
        archetype: &'w Archetype,
        table: &'w Table,
    );

    /// Fetch the [`Self::Item`] for the given entity at the given table row
    ///
    /// # Safety
    ///
    /// - `state` must be fetchable to `Self::Item`
    unsafe fn filter_terms<'w>(
        world: UnsafeWorldCell<'w>,
        last_run: Tick,
        this_run: Tick,
        state: ThinSlicePtr<'_, TermState<'w>>,
        entity: Entity,
        row: TableRow,
    ) -> bool;

    /// Fetch the [`Self::Item`] for the given entity at the given table row
    ///
    /// # Safety
    ///
    /// - `state` must be fetchable to `Self::Item`
    unsafe fn fetch_terms<'w>(
        world: UnsafeWorldCell<'w>,
        last_run: Tick,
        this_run: Tick,
        state: ThinSlicePtr<'_, TermState<'w>>,
        entity: Entity,
        row: TableRow,
    ) -> Self::Item<'w>;

    /// Fetch the [`Self::Item`] for the given entity at the given table row,
    /// returning None if it does not match
    ///
    /// # Safety
    ///
    /// - `state` must be fetchable to `Self::Item`
    unsafe fn fetch_terms_checked<'w>(
        world: UnsafeWorldCell<'w>,
        last_run: Tick,
        this_run: Tick,
        state: ThinSlicePtr<'_, TermState<'w>>,
        entity: Entity,
        row: TableRow,
    ) -> Option<Self::Item<'w>>;

    /// Returns `true` if this query matches a set of components. Otherwise, returns `false`.'
    ///
    /// # Safety
    ///
    /// - `state` must be generated by [`Self::init_term_state`]
    unsafe fn set_matches_states(
        state: ThinSlicePtr<'_, TermState<'_>>,
        set_contains_id: &impl Fn(ComponentId) -> bool,
    ) -> bool;
}

// Blanket implementatinon of [`QueryFetch`] for all tuples of [`QueryFetch`]
macro_rules! impl_query_term_tuple {
    ($($term: ident),*) => {
        impl<$($term: QueryFetchGroup),*> QueryFetchGroup for ($($term,)*) {
            type Item<'w> = ($($term::Item<'w>,)*);
            type ReadOnly = ($($term::ReadOnly,)*);

            const DENSE: bool = true $(&& $term::DENSE)*;
            const SIZE: usize = 0 $(+ $term::SIZE)*;

            #[inline]
            fn init_terms(_world: &mut World, _terms: &mut Vec<Term>, _depth: u8) {
                let _depth = _depth + 1;
                $(
                    $term::init_terms(_world, _terms, _depth);
                )*
            }

            #[inline]
            unsafe fn init_term_states<'w>(
                _world: UnsafeWorldCell<'w>,
                mut _term: ThinSlicePtr<'_, Term>,
                _state: &mut Vec<TermState<'w>>
            ) {
                $(
                    $term::init_term_states(_world, _term, _state);
                    _term.add($term::SIZE);
                )*
            }

            #[inline]
            unsafe fn set_term_tables<'w>(
                mut _state: ThinSlicePtr<'_, TermState<'w>>,
                _table: &'w Table,
            ) {
                $(
                    $term::set_term_tables(_state, _table);
                    _state.add($term::SIZE);
                )*
            }

            #[inline]
            unsafe fn set_term_archetypes<'w>(
                mut _state: ThinSlicePtr<'_, TermState<'w>>,
                _archetype: &'w Archetype,
                _table: &'w Table,
            ) {
                $(
                    $term::set_term_archetypes(_state, _archetype, _table);
                    _state.add($term::SIZE);
                )*
            }

            #[allow(clippy::unused_unit)]
            #[inline(always)]
            unsafe fn filter_terms<'w>(
                _world: UnsafeWorldCell<'w>,
                _last_run: Tick,
                _this_run: Tick,
                mut _state: ThinSlicePtr<'_, TermState<'w>>,
                _entity: Entity,
                _row: TableRow
            ) -> bool {
                true $(&&
                    {
                        let item = $term::filter_terms(_world, _last_run, _this_run, _state, _entity, _row);
                        _state.add($term::SIZE);
                        item
                    }
                )*
            }


            #[allow(clippy::unused_unit)]
            #[inline(always)]
            unsafe fn fetch_terms<'w>(
                _world: UnsafeWorldCell<'w>,
                _last_run: Tick,
                _this_run: Tick,
                mut _state: ThinSlicePtr<'_, TermState<'w>>,
                _entity: Entity,
                _row: TableRow
            ) -> Self::Item<'w> {
                ($({
                    let item = $term::fetch_terms(_world, _last_run, _this_run, _state, _entity, _row);
                    _state.add($term::SIZE);
                    item
                },)*)
            }

            #[allow(clippy::unused_unit)]
            #[inline(always)]
            unsafe fn fetch_terms_checked<'w>(
                _world: UnsafeWorldCell<'w>,
                _last_run: Tick,
                _this_run: Tick,
                mut _state: ThinSlicePtr<'_, TermState<'w>>,
                _entity: Entity,
                _row: TableRow
            ) -> Option<Self::Item<'w>> {
                Some(($({
                    let item = $term::fetch_terms_checked(_world, _last_run, _this_run, _state, _entity, _row)?;
                    _state.add($term::SIZE);
                    item
                },)*))
            }

            #[inline]
            unsafe fn set_matches_states(
                mut _state: ThinSlicePtr<'_, TermState<'_>>,
                _set_contains_id: &impl Fn(ComponentId) -> bool,
            ) -> bool {
                true $(&& {
                    let item = $term::set_matches_states(_state, _set_contains_id);
                    _state.add($term::SIZE);
                    item
                })*
            }
        }
    };
}

all_tuples!(impl_query_term_tuple, 0, 15, T);

impl<Q: QueryFetch> QueryFetchGroup for Q {
    type Item<'w> = Q::Item<'w>;
    type ReadOnly = Q::ReadOnly;

    const DENSE: bool = Q::DENSE;
    const SIZE: usize = 1;

    fn init_terms(world: &mut World, terms: &mut Vec<Term>, depth: u8) {
        terms.push(Q::init_term(world, Term::new(depth)));
    }

    unsafe fn init_term_states<'w>(
        world: UnsafeWorldCell<'w>,
        term: ThinSlicePtr<'_, Term>,
        state: &mut Vec<TermState<'w>>,
    ) {
        state.push(Q::init_term_state(world, term.get(0)));
    }

    #[inline(always)]
    unsafe fn set_term_tables<'w>(mut state: ThinSlicePtr<'_, TermState<'w>>, table: &'w Table) {
        Q::set_term_table(state.get_mut(0), table);
    }

    #[inline(always)]
    unsafe fn set_term_archetypes<'w>(
        mut state: ThinSlicePtr<'_, TermState<'w>>,
        archetype: &'w Archetype,
        table: &'w Table,
    ) {
        Q::set_term_archetype(state.get_mut(0), archetype, table);
    }

    #[inline(always)]
    unsafe fn filter_terms<'w>(
        world: UnsafeWorldCell<'w>,
        last_run: Tick,
        this_run: Tick,
        state: ThinSlicePtr<'_, TermState<'w>>,
        entity: Entity,
        row: TableRow,
    ) -> bool {
        Q::filter_term(world, last_run, this_run, state.get(0), entity, row)
    }

    #[inline(always)]
    unsafe fn fetch_terms<'w>(
        world: UnsafeWorldCell<'w>,
        last_run: Tick,
        this_run: Tick,
        state: ThinSlicePtr<'_, TermState<'w>>,
        entity: Entity,
        row: TableRow,
    ) -> Self::Item<'w> {
        Q::fetch_term(world, last_run, this_run, state.get(0), entity, row)
    }

    #[inline(always)]
    unsafe fn fetch_terms_checked<'w>(
        world: UnsafeWorldCell<'w>,
        last_run: Tick,
        this_run: Tick,
        state: ThinSlicePtr<'_, TermState<'w>>,
        entity: Entity,
        row: TableRow,
    ) -> Option<Self::Item<'w>> {
        let state = state.get(0);
        if state.matches {
            Some(Q::fetch_term(world, last_run, this_run, state, entity, row))
        } else {
            None
        }
    }

    #[inline(always)]
    unsafe fn set_matches_states(
        mut state: ThinSlicePtr<'_, TermState<'_>>,
        set_contains_id: &impl Fn(ComponentId) -> bool,
    ) -> bool {
        Q::set_matches_state(state.get_mut(0), set_contains_id)
    }
}

impl QueryFetch for Entity {
    type Item<'w> = Self;
    type ReadOnly = Self;

    const DENSE: bool = true;

    #[inline]
    fn init_term(_world: &mut World, term: Term) -> Term {
        term
    }

    #[inline]
    unsafe fn init_term_state<'w>(_world: UnsafeWorldCell<'w>, _term: &Term) -> TermState<'w> {
        TermState::empty()
    }

    #[inline(always)]
    unsafe fn fetch_term<'w>(
        _world: UnsafeWorldCell<'w>,
        _last_run: Tick,
        _this_run: Tick,
        _state: &TermState<'w>,
        entity: Entity,
        _row: TableRow,
    ) -> Self::Item<'w> {
        entity
    }

    unsafe fn matches_component_set(
        _state: &TermState<'_>,
        _set_contains_id: &impl Fn(ComponentId) -> bool,
    ) -> bool {
        true
    }
}

impl QueryFetch for EntityRef<'_> {
    type Item<'w> = EntityRef<'w>;
    type ReadOnly = Self;

    const DENSE: bool = true;

    #[inline]
    fn init_term(_world: &mut World, term: Term) -> Term {
        term.with_access(TermAccess::Read)
    }

    #[inline]
    unsafe fn init_term_state<'w>(_world: UnsafeWorldCell<'w>, _term: &Term) -> TermState<'w> {
        TermState::empty()
    }

    #[inline(always)]
    unsafe fn fetch_term<'w>(
        world: UnsafeWorldCell<'w>,
        _last_run: Tick,
        _this_run: Tick,
        _state: &TermState<'w>,
        entity: Entity,
        _row: TableRow,
    ) -> Self::Item<'w> {
        EntityRef::new(world.get_entity(entity).debug_checked_unwrap())
    }

    #[inline]
    unsafe fn matches_component_set(
        _state: &TermState<'_>,
        _set_contains_id: &impl Fn(ComponentId) -> bool,
    ) -> bool {
        true
    }
}

impl<'r> QueryFetch for EntityMut<'r> {
    type Item<'w> = EntityMut<'w>;
    type ReadOnly = EntityRef<'r>;

    const DENSE: bool = true;

    #[inline]
    fn init_term(_world: &mut World, term: Term) -> Term {
        term.with_access(TermAccess::Write)
    }

    #[inline]
    unsafe fn init_term_state<'w>(_world: UnsafeWorldCell<'w>, _term: &Term) -> TermState<'w> {
        TermState::empty()
    }

    #[inline(always)]
    unsafe fn fetch_term<'w>(
        world: UnsafeWorldCell<'w>,
        _last_run: Tick,
        _this_run: Tick,
        _state: &TermState<'w>,
        entity: Entity,
        _row: TableRow,
    ) -> Self::Item<'w> {
        EntityMut::new(world.get_entity(entity).debug_checked_unwrap())
    }

    #[inline]
    unsafe fn matches_component_set(
        _state: &TermState<'_>,
        _set_contains_id: &impl Fn(ComponentId) -> bool,
    ) -> bool {
        true
    }
}

impl<T: Component> QueryFetch for Has<T> {
    type Item<'w> = bool;
    type ReadOnly = Self;

    const DENSE: bool = true;

    #[inline]
    fn init_term(world: &mut World, term: Term) -> Term {
        let component = world.init_component::<T>();
        term.with_id(component).with_filter(TermFilter::Optional)
    }

    #[inline]
    unsafe fn init_term_state<'w>(_world: UnsafeWorldCell<'w>, term: &Term) -> TermState<'w> {
        let component = term.component.debug_checked_unwrap();
        TermState::new(ComponentState {
            ptr: None,
            id: component,
            set: None,
            size: 0,
        })
    }

    #[inline(always)]
    unsafe fn set_term_table<'w>(state: &mut TermState<'w>, table: &'w Table) {
        let id = state.component.as_ref().debug_checked_unwrap().id;
        state.matches = table.has_column(id);
    }

    #[inline(always)]
    unsafe fn set_term_archetype<'w>(
        state: &mut TermState<'w>,
        archetype: &'w Archetype,
        _table: &'w Table,
    ) {
        let id = state.component.as_ref().debug_checked_unwrap().id;
        state.matches = archetype.contains(id);
    }

    #[inline(always)]
    unsafe fn fetch_term<'w>(
        _world: UnsafeWorldCell<'w>,
        _last_run: Tick,
        _this_run: Tick,
        state: &TermState<'w>,
        _entity: Entity,
        _row: TableRow,
    ) -> Self::Item<'w> {
        state.matches
    }

    #[inline]
    unsafe fn matches_component_set(
        _state: &TermState<'_>,
        _set_contains_id: &impl Fn(ComponentId) -> bool,
    ) -> bool {
        true
    }
}

impl<T: Component> QueryFetch for &T {
    type Item<'w> = &'w T;
    type ReadOnly = Self;

    const DENSE: bool = match T::Storage::STORAGE_TYPE {
        StorageType::Table => true,
        StorageType::SparseSet => false,
    };

    fn init_term(world: &mut World, term: Term) -> Term {
        let component = world.init_component::<T>();
        term.with_id(component).with_access(TermAccess::Read)
    }

    unsafe fn init_term_state<'w>(world: UnsafeWorldCell<'w>, term: &Term) -> TermState<'w> {
        let component = term.component.debug_checked_unwrap();
        let info = world.components().get_info_unchecked(component);
        if T::Storage::STORAGE_TYPE == StorageType::Table {
            TermState::new(ComponentState {
                ptr: None,
                id: component,
                size: info.layout().size(),
                set: None,
            })
        } else {
            let set = world
                .storages()
                .sparse_sets
                .get(component)
                .debug_checked_unwrap();
            TermState::new(ComponentState {
                ptr: None,
                id: component,
                size: info.layout().size(),
                set: Some(set),
            })
        }
    }

    #[inline(always)]
    unsafe fn set_term_table<'w>(state: &mut TermState<'w>, table: &'w Table) {
        state.matches = true;
        if T::Storage::STORAGE_TYPE == StorageType::Table {
            let component = state.component.as_mut().debug_checked_unwrap();
            let column = table.get_column(component.id).debug_checked_unwrap();
            component.ptr = Some(ComponentPtr {
                component: column.get_data_ptr(),
                added: None,
                changed: None,
            });
        }
    }

    #[inline(always)]
    unsafe fn set_term_archetype<'w>(
        state: &mut TermState<'w>,
        _archetype: &'w Archetype,
        table: &'w Table,
    ) {
        Self::set_term_table(state, table);
    }

    #[inline(always)]
    unsafe fn fetch_term<'w>(
        _world: UnsafeWorldCell<'w>,
        _last_run: Tick,
        _this_run: Tick,
        state: &TermState<'w>,
        entity: Entity,
        row: TableRow,
    ) -> Self::Item<'w> {
        let component = state.component.as_ref().debug_checked_unwrap();
        match T::Storage::STORAGE_TYPE {
            StorageType::Table => {
                let table = component.ptr.as_ref().debug_checked_unwrap();
                table
                    .component
                    .byte_add(row.index() * std::mem::size_of::<T>())
                    .deref()
            }
            StorageType::SparseSet => {
                let set = component.set.debug_checked_unwrap();
                set.get(entity).debug_checked_unwrap().deref()
            }
        }
    }

    unsafe fn matches_component_set(
        state: &TermState<'_>,
        set_contains_id: &impl Fn(ComponentId) -> bool,
    ) -> bool {
        set_contains_id(state.component.as_ref().debug_checked_unwrap().id)
    }
}

impl<T: Component> QueryFetch for Ref<'_, T> {
    type Item<'w> = Ref<'w, T>;
    type ReadOnly = Self;

    const DENSE: bool = match T::Storage::STORAGE_TYPE {
        StorageType::Table => true,
        StorageType::SparseSet => false,
    };

    fn init_term(world: &mut World, term: Term) -> Term {
        let component = world.init_component::<T>();
        term.with_id(component)
            .with_access(TermAccess::Read)
            .with_change_detection()
    }

    unsafe fn init_term_state<'w>(world: UnsafeWorldCell<'w>, term: &Term) -> TermState<'w> {
        let component = term.component.debug_checked_unwrap();
        let info = world.components().get_info_unchecked(component);
        if T::Storage::STORAGE_TYPE == StorageType::Table {
            TermState::new(ComponentState {
                ptr: None,
                id: component,
                size: info.layout().size(),
                set: None,
            })
        } else {
            let set = world
                .storages()
                .sparse_sets
                .get(component)
                .debug_checked_unwrap();
            TermState::new(ComponentState {
                ptr: None,
                id: component,
                size: info.layout().size(),
                set: Some(set),
            })
        }
    }

    #[inline(always)]
    unsafe fn set_term_table<'w>(state: &mut TermState<'w>, table: &'w Table) {
        state.matches = true;
        if T::Storage::STORAGE_TYPE == StorageType::Table {
            let component = state.component.as_mut().debug_checked_unwrap();
            let column = table.get_column(component.id).debug_checked_unwrap();
            component.ptr = Some(ComponentPtr {
                component: column.get_data_ptr(),
                added: Some(column.get_added_ticks_slice().into()),
                changed: Some(column.get_changed_ticks_slice().into()),
            });
        }
    }

    #[inline(always)]
    unsafe fn set_term_archetype<'w>(
        state: &mut TermState<'w>,
        _archetype: &'w Archetype,
        table: &'w Table,
    ) {
        Self::set_term_table(state, table);
    }

    #[inline(always)]
    unsafe fn fetch_term<'w>(
        _world: UnsafeWorldCell<'w>,
        last_run: Tick,
        this_run: Tick,
        state: &TermState<'w>,
        entity: Entity,
        row: TableRow,
    ) -> Self::Item<'w> {
        let component = state.component.as_ref().debug_checked_unwrap();
        if T::Storage::STORAGE_TYPE == StorageType::Table {
            let ptr = component.ptr.as_ref().debug_checked_unwrap();
            Ref {
                value: ptr.component.byte_add(component.size * row.index()).deref(),
                ticks: Ticks {
                    added: ptr.added.debug_checked_unwrap().get(row.index()).deref(),
                    changed: ptr.changed.debug_checked_unwrap().get(row.index()).deref(),
                    last_run,
                    this_run,
                },
            }
        } else {
            let set = component.set.debug_checked_unwrap();
            let (ptr, ticks) = set.get_with_ticks(entity).debug_checked_unwrap();
            Ref {
                value: ptr.deref(),
                ticks: Ticks {
                    added: ticks.added.deref(),
                    changed: ticks.changed.deref(),
                    last_run,
                    this_run,
                },
            }
        }
    }

    unsafe fn matches_component_set(
        state: &TermState<'_>,
        set_contains_id: &impl Fn(ComponentId) -> bool,
    ) -> bool {
        set_contains_id(state.component.as_ref().debug_checked_unwrap().id)
    }
}

impl QueryFetch for Ptr<'_> {
    type Item<'w> = Ptr<'w>;
    type ReadOnly = Self;

    const DENSE: bool = false;

    fn init_term(_world: &mut World, term: Term) -> Term {
        term.with_access(TermAccess::Read)
    }

    unsafe fn init_term_state<'w>(world: UnsafeWorldCell<'w>, term: &Term) -> TermState<'w> {
        let component = term.component.debug_checked_unwrap();
        let info = world.components().get_info_unchecked(component);
        if info.storage_type() == StorageType::Table {
            TermState::new(ComponentState {
                ptr: None,
                id: component,
                size: info.layout().size(),
                set: None,
            })
        } else {
            let set = world
                .storages()
                .sparse_sets
                .get(component)
                .debug_checked_unwrap();
            TermState::new(ComponentState {
                ptr: None,
                id: component,
                size: info.layout().size(),
                set: Some(set),
            })
        }
    }

    #[inline(always)]
    unsafe fn set_term_table<'w>(state: &mut TermState<'w>, table: &'w Table) {
        let component = state.component.as_ref().debug_checked_unwrap();
        if component.set.is_none() {
            let component = state.component.as_mut().debug_checked_unwrap();
            let column = table.get_column(component.id).debug_checked_unwrap();
            component.ptr = Some(ComponentPtr {
                component: column.get_data_ptr(),
                added: None,
                changed: None,
            });
        }
    }

    #[inline(always)]
    unsafe fn set_term_archetype<'w>(
        state: &mut TermState<'w>,
        _archetype: &'w Archetype,
        table: &'w Table,
    ) {
        Self::set_term_table(state, table);
    }

    #[inline(always)]
    unsafe fn fetch_term<'w>(
        _world: UnsafeWorldCell<'w>,
        _last_run: Tick,
        _this_run: Tick,
        state: &TermState<'w>,
        entity: Entity,
        row: TableRow,
    ) -> Self::Item<'w> {
        let component = state.component.as_ref().debug_checked_unwrap();
        if let Some(set) = component.set {
            set.get(entity).debug_checked_unwrap()
        } else {
            let ptr = component.ptr.as_ref().debug_checked_unwrap();
            ptr.component.byte_add(component.size * row.index())
        }
    }

    unsafe fn matches_component_set(
        state: &TermState<'_>,
        set_contains_id: &impl Fn(ComponentId) -> bool,
    ) -> bool {
        set_contains_id(state.component.as_ref().debug_checked_unwrap().id)
    }
}

impl<'r, T: Component> QueryFetch for &'r mut T {
    type Item<'w> = Mut<'w, T>;
    type ReadOnly = &'r T;

    const DENSE: bool = match T::Storage::STORAGE_TYPE {
        StorageType::Table => true,
        StorageType::SparseSet => false,
    };

    fn init_term(world: &mut World, term: Term) -> Term {
        let component = world.init_component::<T>();
        term.with_id(component)
            .with_access(TermAccess::Write)
            .with_change_detection()
    }

    unsafe fn init_term_state<'w>(world: UnsafeWorldCell<'w>, term: &Term) -> TermState<'w> {
        let component = term.component.debug_checked_unwrap();
        let info = world.components().get_info_unchecked(component);
        if T::Storage::STORAGE_TYPE == StorageType::Table {
            TermState::new(ComponentState {
                ptr: None,
                id: component,
                size: info.layout().size(),
                set: None,
            })
        } else {
            let set = world
                .storages()
                .sparse_sets
                .get(component)
                .debug_checked_unwrap();
            TermState::new(ComponentState {
                ptr: None,
                id: component,
                size: info.layout().size(),
                set: Some(set),
            })
        }
    }

    #[inline(always)]
    unsafe fn set_term_table<'w>(state: &mut TermState<'w>, table: &'w Table) {
        if T::Storage::STORAGE_TYPE == StorageType::Table {
            let component = state.component.as_mut().debug_checked_unwrap();
            let column = table.get_column(component.id).debug_checked_unwrap();
            component.ptr = Some(ComponentPtr {
                component: column.get_data_ptr(),
                added: Some(column.get_added_ticks_slice().into()),
                changed: Some(column.get_changed_ticks_slice().into()),
            });
        }
    }

    #[inline(always)]
    unsafe fn set_term_archetype<'w>(
        state: &mut TermState<'w>,
        _archetype: &'w Archetype,
        table: &'w Table,
    ) {
        Self::set_term_table(state, table);
    }

    #[inline(always)]
    unsafe fn fetch_term<'w>(
        _world: UnsafeWorldCell<'w>,
        last_run: Tick,
        this_run: Tick,
        state: &TermState<'w>,
        entity: Entity,
        row: TableRow,
    ) -> Self::Item<'w> {
        let component = state.component.as_ref().debug_checked_unwrap();
        if T::Storage::STORAGE_TYPE == StorageType::Table {
            let ptr = component.ptr.as_ref().debug_checked_unwrap();
            Mut {
                value: ptr
                    .component
                    .assert_unique()
                    .byte_add(size_of::<T>() * row.index())
                    .deref_mut(),
                ticks: TicksMut {
                    added: ptr
                        .added
                        .debug_checked_unwrap()
                        .get(row.index())
                        .deref_mut(),
                    changed: ptr
                        .changed
                        .debug_checked_unwrap()
                        .get(row.index())
                        .deref_mut(),
                    last_run,
                    this_run,
                },
            }
        } else {
            let set = component.set.debug_checked_unwrap();
            let (ptr, ticks) = set.get_with_ticks(entity).debug_checked_unwrap();
            Mut {
                value: ptr.assert_unique().deref_mut(),
                ticks: TicksMut {
                    added: ticks.added.deref_mut(),
                    changed: ticks.changed.deref_mut(),
                    last_run,
                    this_run,
                },
            }
        }
    }

    unsafe fn matches_component_set(
        state: &TermState<'_>,
        set_contains_id: &impl Fn(ComponentId) -> bool,
    ) -> bool {
        set_contains_id(state.component.as_ref().debug_checked_unwrap().id)
    }
}

impl<'r> QueryFetch for PtrMut<'r> {
    type Item<'w> = MutUntyped<'w>;
    type ReadOnly = Ptr<'r>;

    const DENSE: bool = false;

    fn init_term(_world: &mut World, term: Term) -> Term {
        term.with_access(TermAccess::Write).with_change_detection()
    }

    unsafe fn init_term_state<'w>(world: UnsafeWorldCell<'w>, term: &Term) -> TermState<'w> {
        let component = term.component.debug_checked_unwrap();
        let info = world.components().get_info_unchecked(component);
        if info.storage_type() == StorageType::Table {
            TermState::new(ComponentState {
                ptr: None,
                id: component,
                size: info.layout().size(),
                set: None,
            })
        } else {
            let set = world
                .storages()
                .sparse_sets
                .get(component)
                .debug_checked_unwrap();
            TermState::new(ComponentState {
                ptr: None,
                id: component,
                size: info.layout().size(),
                set: Some(set),
            })
        }
    }

    #[inline(always)]
    unsafe fn set_term_table<'w>(state: &mut TermState<'w>, table: &'w Table) {
        let component = state.component.as_ref().debug_checked_unwrap();
        if component.set.is_none() {
            let component = state.component.as_mut().debug_checked_unwrap();
            let column = table.get_column(component.id).debug_checked_unwrap();
            component.ptr = Some(ComponentPtr {
                component: column.get_data_ptr(),
                added: Some(column.get_added_ticks_slice().into()),
                changed: Some(column.get_changed_ticks_slice().into()),
            });
        }
    }

    #[inline(always)]
    unsafe fn set_term_archetype<'w>(
        state: &mut TermState<'w>,
        _archetype: &'w Archetype,
        table: &'w Table,
    ) {
        Self::set_term_table(state, table);
    }

    #[inline(always)]
    unsafe fn fetch_term<'w>(
        _world: UnsafeWorldCell<'w>,
        last_run: Tick,
        this_run: Tick,
        state: &TermState<'w>,
        entity: Entity,
        row: TableRow,
    ) -> Self::Item<'w> {
        let component = state.component.as_ref().debug_checked_unwrap();
        if let Some(set) = component.set {
            let (ptr, ticks) = set.get_with_ticks(entity).debug_checked_unwrap();
            MutUntyped {
                value: ptr.assert_unique(),
                ticks: TicksMut {
                    added: ticks.added.deref_mut(),
                    changed: ticks.changed.deref_mut(),
                    last_run,
                    this_run,
                },
            }
        } else {
            let ptr = component.ptr.as_ref().debug_checked_unwrap();
            MutUntyped {
                value: ptr
                    .component
                    .byte_add(component.size * row.index())
                    .assert_unique(),
                ticks: TicksMut {
                    added: ptr
                        .added
                        .debug_checked_unwrap()
                        .get(row.index())
                        .deref_mut(),
                    changed: ptr
                        .changed
                        .debug_checked_unwrap()
                        .get(row.index())
                        .deref_mut(),
                    last_run,
                    this_run,
                },
            }
        }
    }

    unsafe fn matches_component_set(
        state: &TermState<'_>,
        set_contains_id: &impl Fn(ComponentId) -> bool,
    ) -> bool {
        set_contains_id(state.component.as_ref().debug_checked_unwrap().id)
    }
}

impl<Q: QueryFetch> QueryFetch for Option<Q> {
    type Item<'w> = Option<Q::Item<'w>>;
    type ReadOnly = Option<Q::ReadOnly>;

    const DENSE: bool = Q::DENSE;

    fn init_term(world: &mut World, term: Term) -> Term {
        Q::init_term(world, term).with_filter(TermFilter::Optional)
    }

    unsafe fn init_term_state<'w>(world: UnsafeWorldCell<'w>, term: &Term) -> TermState<'w> {
        Q::init_term_state(world, term)
    }

    unsafe fn set_term_table<'w>(state: &mut TermState<'w>, table: &'w Table) {
        state.matches = Q::matches_component_set(state, &|id| table.has_column(id));
        if state.matches {
            Q::set_term_table(state, table);
        }
    }

    unsafe fn set_term_archetype<'w>(
        state: &mut TermState<'w>,
        archetype: &'w Archetype,
        table: &'w Table,
    ) {
        state.matches = Q::matches_component_set(state, &|id| archetype.contains(id));
        if state.matches {
            Q::set_term_archetype(state, archetype, table);
        }
    }

    #[inline(always)]
    unsafe fn fetch_term<'w>(
        world: UnsafeWorldCell<'w>,
        last_run: Tick,
        this_run: Tick,
        state: &TermState<'w>,
        entity: Entity,
        row: TableRow,
    ) -> Self::Item<'w> {
        if state.matches {
            Some(Q::fetch_term(world, last_run, this_run, state, entity, row))
        } else {
            None
        }
    }

    unsafe fn matches_component_set(
        _state: &TermState<'_>,
        _set_contains_id: &impl Fn(ComponentId) -> bool,
    ) -> bool {
        true
    }
}

// Blanket implementatinon of [`QueryFetch`] for all tuples of [`QueryFetch`]
macro_rules! any_of_term_tuple {
    ($($term: ident),*) => {
        impl<$($term: QueryFetchGroup),*> QueryFetchGroup for AnyOf<($($term,)*)> {
            type Item<'w> = ($(Option<$term::Item<'w>>,)*);
            type ReadOnly = AnyOf<($($term::ReadOnly,)*)>;

            const DENSE: bool = true $(&& $term::DENSE)*;
            const SIZE: usize = 0 $(+ $term::SIZE)*;

            #[inline]
            fn init_terms(_world: &mut World, _terms: &mut Vec<Term>, _depth: u8) {
                $(
                    $term::init_terms(_world, _terms, _depth);
                    if let Some(last) = _terms.last_mut() {
                        last.or = true;
                    }
                )*
                if let Some(last) = _terms.last_mut() {
                    last.or = false;
                }
            }

            #[inline]
            unsafe fn init_term_states<'w>(
                _world: UnsafeWorldCell<'w>,
                mut _term: ThinSlicePtr<'_, Term>,
                _state: &mut Vec<TermState<'w>>,
            ) {
                $(
                    $term::init_term_states(_world, _term, _state);
                    _term.add($term::SIZE);
                )*
            }

            #[inline]
            unsafe fn set_term_tables<'w>(
                mut _state: ThinSlicePtr<'_, TermState<'w>>,
                _table: &'w Table,
            ) {
                $(
                    if $term::set_matches_states(_state, &|id| _table.has_column(id)) {
                        <$term>::set_term_tables(_state, _table);
                    }
                    _state.add($term::SIZE);
                )*
            }

            #[inline]
            unsafe fn set_term_archetypes<'w>(
                mut _state: ThinSlicePtr<'_, TermState<'w>>,
                _archetype: &'w Archetype,
                _table: &'w Table,
            ) {
                $(
                    if $term::set_matches_states(_state, &|id| _archetype.contains(id)) {
                        <$term>::set_term_archetypes(_state, _archetype, _table);
                    }
                    _state.add($term::SIZE);
                )*
            }

            #[allow(clippy::unused_unit)]
            #[inline(always)]
            unsafe fn filter_terms<'w>(
                _world: UnsafeWorldCell<'w>,
                _last_run: Tick,
                _this_run: Tick,
                mut _state: ThinSlicePtr<'_, TermState<'w>>,
                _entity: Entity,
                _row: TableRow
            ) -> bool {
                false $(||
                    {
                        let item = $term::filter_terms(_world, _last_run, _this_run, _state, _entity, _row);
                        _state.add($term::SIZE);
                        item
                    }
                )*
            }

            #[allow(clippy::unused_unit)]
            #[inline(always)]
            unsafe fn fetch_terms<'w>(
                _world: UnsafeWorldCell<'w>,
                _last_run: Tick,
                _this_run: Tick,
                mut _state: ThinSlicePtr<'_, TermState<'w>>,
                _entity: Entity,
                _row: TableRow
            ) -> Self::Item<'w> {
                ($(
                    {
                        let item = <$term>::fetch_terms_checked(_world, _last_run, _this_run, _state, _entity, _row);
                        _state.add($term::SIZE);
                        item
                    },
                )*)
            }

            #[allow(clippy::unused_unit)]
            #[inline(always)]
            unsafe fn fetch_terms_checked<'w>(
                _world: UnsafeWorldCell<'w>,
                _last_run: Tick,
                _this_run: Tick,
                mut _state: ThinSlicePtr<'_, TermState<'w>>,
                _entity: Entity,
                _row: TableRow
            ) -> Option<Self::Item<'w>> {
                Some(($(
                    {
                        let item = <$term>::fetch_terms_checked(_world, _last_run, _this_run, _state, _entity, _row);
                        _state.add($term::SIZE);
                        item
                    },
                )*))
            }

            unsafe fn set_matches_states(
                mut _state: ThinSlicePtr<'_, TermState<'_>>,
                _set_contains_id: &impl Fn(ComponentId) -> bool,
            ) -> bool {
                false $(|| {
                    let item = $term::set_matches_states(_state, _set_contains_id);
                    _state.add($term::SIZE);
                    item
                })*
            }
        }
    };
}

all_tuples!(any_of_term_tuple, 1, 15, T);

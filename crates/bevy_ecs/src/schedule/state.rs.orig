<<<<<<< HEAD
use std::any::{Any, TypeId};

use crate::{
    In, IntoChainSystem, IntoSystem, Local, Res, ResMut, Resource, ShouldRun, System, SystemSet,
};
=======
use crate::{
    component::Component,
    schedule::{Stage, SystemDescriptor, SystemStage},
    world::World,
};
use bevy_utils::HashMap;
use std::{mem::Discriminant, ops::Deref};
>>>>>>> main
use thiserror::Error;

type Something = Box<dyn Any + Send + Sync>;

/// ### Stack based state machine
///
/// This state machine has three operations: Next, Pop, and Push.
/// * Push pushes a new state to the state stack, pausing the previous state
/// * Pop removes the current state, and unpauses the last paused state.
/// * Next unwinds the state stack, and replaces the entire stack with a single new state
#[derive(Debug)]
pub struct State {
    transition: Option<StateTransition>,
    stack: Vec<Something>,
    scheduled: Option<ScheduledOperation>,
    ran_update: bool,
}

#[derive(Debug)]
enum StateTransition {
    PreStartup,
    Startup,
    // The parameter order is always (leaving, entering)
    ExitingToResume(TypeId, TypeId),
    ExitingFull(TypeId, Something),
    Entering(TypeId, TypeId),
    Resuming(TypeId, TypeId),
    Pausing(TypeId, Something),
}

#[derive(Debug)]
enum ScheduledOperation {
    Next(Something),
    Pop,
    Push(Something),
}

impl State {
    pub fn on_update<T: Resource>() -> impl System<In = (), Out = ShouldRun> {
        (|state: Res<State>| {
            state.stack.last().unwrap().as_ref().type_id() == TypeId::of::<T>()
                && state.transition.is_none()
        })
        .system()
        .chain(should_run_adapter.system())
    }

    pub fn on_inactive_update<T: Resource>() -> impl System<In = (), Out = ShouldRun> {
        (|state: Res<State>, mut is_inactive: Local<bool>| match &state.transition {
            Some(StateTransition::Pausing(ref relevant, _))
            | Some(StateTransition::Resuming(_, ref relevant)) => {
                if relevant == &TypeId::of::<T>() {
                    *is_inactive = !*is_inactive;
                }
                false
            }
            Some(_) => false,
            None => *is_inactive,
        })
        .system()
        .chain(should_run_adapter.system())
    }

    pub fn on_in_stack_update<T: Resource>() -> impl System<In = (), Out = ShouldRun> {
        (|state: Res<State>, mut is_in_stack: Local<bool>| match &state.transition {
            Some(StateTransition::Entering(ref relevant, _))
            | Some(StateTransition::ExitingToResume(_, ref relevant)) => {
                if relevant == &TypeId::of::<T>() {
                    *is_in_stack = !*is_in_stack;
                }
                false
            }
            Some(StateTransition::ExitingFull(_, ref relevant)) => {
                if relevant.type_id() == TypeId::of::<T>() {
                    *is_in_stack = !*is_in_stack;
                }
                false
            }
            Some(StateTransition::Startup) => {
                if state.stack.last().unwrap().as_ref().type_id() == TypeId::of::<T>() {
                    *is_in_stack = !*is_in_stack;
                }
                false
            }
            Some(_) => false,
            None => *is_in_stack,
        })
        .system()
        .chain(should_run_adapter.system())
    }

    pub fn on_enter<T: Resource>() -> impl System<In = (), Out = ShouldRun> {
        (|state: Res<State>| {
            state
                .transition
                .as_ref()
                .map_or(false, |transition| match transition {
                    StateTransition::Entering(_, entering) => entering == &TypeId::of::<T>(),
                    StateTransition::Startup => {
                        state.stack.last().unwrap().as_ref().type_id() == TypeId::of::<T>()
                    }
                    _ => false,
                })
        })
        .system()
        .chain(should_run_adapter.system())
    }

    pub fn on_exit<T: Resource>() -> impl System<In = (), Out = ShouldRun> {
        (|state: Res<State>| {
            state
                .transition
                .as_ref()
                .map_or(false, |transition| match transition {
                    StateTransition::ExitingToResume(exiting, _)
                    | StateTransition::ExitingFull(exiting, _) => exiting == &TypeId::of::<T>(),
                    _ => false,
                })
        })
        .system()
        .chain(should_run_adapter.system())
    }

    pub fn on_pause<T: Resource>() -> impl System<In = (), Out = ShouldRun> {
        (|state: Res<State>| {
            state
                .transition
                .as_ref()
                .map_or(false, |transition| match transition {
                    StateTransition::Pausing(pausing, _) => pausing == &TypeId::of::<T>(),
                    _ => false,
                })
        })
        .system()
        .chain(should_run_adapter.system())
    }

    pub fn on_resume<T: Resource>() -> impl System<In = (), Out = ShouldRun> {
        (|state: Res<State>| {
            state
                .transition
                .as_ref()
                .map_or(false, |transition| match transition {
                    StateTransition::Resuming(_, resuming) => resuming == &TypeId::of::<T>(),
                    _ => false,
                })
        })
        .system()
        .chain(should_run_adapter.system())
    }

    /// Creates a driver set for the State.
    ///
    /// Important note: this set must be inserted **before** all other state-dependant sets to work properly!
    pub fn make_driver() -> SystemSet {
        SystemSet::default().with_run_criteria(state_cleaner.system())
    }

    pub fn new<T: Any + Resource>(initial: T) -> Self {
        Self {
            stack: vec![Box::new(initial)],
            transition: Some(StateTransition::PreStartup),
            scheduled: None,
            ran_update: false,
        }
    }

    /// Schedule a state change that replaces the full stack with the given state.
    /// This will fail if there is a scheduled operation, or if the given `state` matches the current state
    pub fn set_next<T: Resource>(&mut self, state: T) -> Result<(), StateError> {
        if self.stack.last().unwrap().as_ref().type_id() == TypeId::of::<T>() {
            return Err(StateError::AlreadyInState);
        }

        if self.scheduled.is_some() {
            return Err(StateError::StateAlreadyQueued);
        }

        self.scheduled = Some(ScheduledOperation::Next(Box::new(state)));
        Ok(())
    }

    /// Same as [Self::set_next], but if there is already a next state, it will be overwritten instead of failing
    pub fn overwrite_next<T: Any + Resource>(&mut self, state: T) -> Result<(), StateError> {
        if self.stack.last().unwrap().as_ref().type_id() == TypeId::of::<T>() {
            return Err(StateError::AlreadyInState);
        }

        self.scheduled = Some(ScheduledOperation::Next(Box::new(state)));
        Ok(())
    }

<<<<<<< HEAD
    /// Same as [Self::set_next], but does a push operation instead of a next operation
    pub fn set_push<T: Any + Resource>(&mut self, state: T) -> Result<(), StateError> {
        if self.stack.last().unwrap().as_ref().type_id() == TypeId::of::<T>() {
            return Err(StateError::AlreadyInState);
        }

        if self.scheduled.is_some() {
            return Err(StateError::StateAlreadyQueued);
        }

        self.scheduled = Some(ScheduledOperation::Push(Box::new(state)));
        Ok(())
    }

    /// Same as [Self::set_push], but if there is already a next state, it will be overwritten instead of failing
    pub fn overwrite_push<T: Any + Resource>(&mut self, state: T) -> Result<(), StateError> {
        if self.stack.last().unwrap().as_ref().type_id() == TypeId::of::<T>() {
            return Err(StateError::AlreadyInState);
=======
#[allow(clippy::mem_discriminant_non_enum)]
impl<T: Component + Clone> Stage for StateStage<T> {
    fn run(&mut self, world: &mut World) {
        let current_stage = loop {
            let (next_stage, current_stage) = {
                let mut state = world
                    .get_resource_mut::<State<T>>()
                    .expect("Missing state resource");
                let result = (
                    state.next.as_ref().map(|next| std::mem::discriminant(next)),
                    std::mem::discriminant(&state.current),
                );

                state.apply_next();

                result
            };

            // if next_stage is Some, we just applied a new state
            if let Some(next_stage) = next_stage {
                if next_stage != current_stage {
                    if let Some(current_state_stages) = self.stages.get_mut(&current_stage) {
                        current_state_stages.exit.run(world);
                    }
                }

                if let Some(next_state_stages) = self.stages.get_mut(&next_stage) {
                    next_state_stages.enter.run(world);
                }
            } else {
                break current_stage;
            }
        };

        if let Some(current_state_stages) = self.stages.get_mut(&current_stage) {
            current_state_stages.update.run(world);
>>>>>>> main
        }

        self.scheduled = Some(ScheduledOperation::Push(Box::new(state)));
        Ok(())
    }

    /// Same as [Self::set_next], but does a pop operation instead of a next operation
    pub fn set_pop(&mut self) -> Result<(), StateError> {
        if self.scheduled.is_some() {
            return Err(StateError::StateAlreadyQueued);
        }

        if self.stack.len() == 1 {
            return Err(StateError::StackEmpty);
        }

        self.scheduled = Some(ScheduledOperation::Pop);
        Ok(())
    }

    /// Same as [Self::set_pop], but if there is already a next state, it will be overwritten instead of failing
    pub fn overwrite_pop(&mut self) -> Result<(), StateError> {
        if self.stack.len() == 1 {
            return Err(StateError::StackEmpty);
        }
        self.scheduled = Some(ScheduledOperation::Pop);
        Ok(())
    }

    pub fn current<T: Any + Resource>(&self) -> Option<&T> {
        self.stack.last().unwrap().downcast_ref::<T>()
    }

    pub fn current_as_any(&self) -> &dyn Any {
        self.stack.last().unwrap()
    }

    pub fn is<T: Any + Resource>(&self) -> bool {
        self.stack.last().unwrap().downcast_ref::<T>().is_some()
    }

    pub fn current_mut<T: Any + Resource>(&mut self) -> Option<&mut T> {
        self.stack.last_mut().unwrap().downcast_mut()
    }

    pub fn inactives(&self) -> &[Box<dyn Any + Send + Sync>] {
        &self.stack[0..self.stack.len() - 1]
    }
}

#[derive(Debug, Error)]
pub enum StateError {
    #[error("Attempted to change the state to the current state.")]
    AlreadyInState,
    #[error("Attempted to queue a state change, but there was already a state queued.")]
    StateAlreadyQueued,
    #[error("Attempted to queue a pop, but there is nothing to pop.")]
    StackEmpty,
}

fn should_run_adapter(In(cmp_result): In<bool>, state: Res<State>) -> ShouldRun {
    if state.ran_update {
        return ShouldRun::No;
    }
    if cmp_result {
        ShouldRun::YesAndCheckAgain
    } else {
        ShouldRun::NoAndCheckAgain
    }
}

fn state_cleaner(mut state: ResMut<State>, mut lra: Local<bool>) -> ShouldRun {
    if *lra {
        state.ran_update = true;
        *lra = false;
        return ShouldRun::YesAndCheckAgain;
    } else if state.ran_update {
        state.ran_update = false;
        return ShouldRun::No;
    }
    match state.scheduled.take() {
        Some(ScheduledOperation::Next(next)) => {
            if state.stack.len() <= 1 {
                state.transition = Some(StateTransition::ExitingFull(
                    state.stack.last().unwrap().as_ref().type_id(),
                    next,
                ));
            } else {
                state.scheduled = Some(ScheduledOperation::Next(next));
                match state.transition.take() {
                    Some(StateTransition::ExitingToResume(p, n)) => {
                        state.stack.pop();
                        state.transition = Some(StateTransition::Resuming(p, n));
                    }
                    _ => {
                        state.transition = Some(StateTransition::ExitingToResume(
                            state.stack[state.stack.len() - 1].as_ref().type_id(),
                            state.stack[state.stack.len() - 2].as_ref().type_id(),
                        ));
                    }
                }
            }
        }
        Some(ScheduledOperation::Push(next)) => {
            let last_type_id = state.stack.last().unwrap().as_ref().type_id();
            state.transition = Some(StateTransition::Pausing(last_type_id, next));
        }
        Some(ScheduledOperation::Pop) => {
            state.transition = Some(StateTransition::ExitingToResume(
                state.stack[state.stack.len() - 1].as_ref().type_id(),
                state.stack[state.stack.len() - 2].as_ref().type_id(),
            ));
        }
        None => match state.transition.take() {
            Some(StateTransition::ExitingFull(p, n)) => {
                state.transition = Some(StateTransition::Entering(p, n.as_ref().type_id()));
                state.stack[0] = n;
            }
            Some(StateTransition::Pausing(p, n)) => {
                state.transition = Some(StateTransition::Entering(p, n.as_ref().type_id()));
                state.stack.push(n);
            }
            Some(StateTransition::ExitingToResume(p, n)) => {
                state.stack.pop();
                state.transition = Some(StateTransition::Resuming(p, n));
            }
            Some(StateTransition::PreStartup) => {
                state.transition = Some(StateTransition::Startup);
            }
            _ => {}
        },
    };
    if state.transition.is_none() {
        *lra = true;
    }

    ShouldRun::YesAndCheckAgain
}

#[cfg(test)]
mod test {
    use crate::prelude::*;

    mod my_state {
        pub struct S1;
        pub struct S2;
        pub struct S3;
        pub struct S4;
        pub struct S5;
        pub struct S6;
        pub struct Final;
    }

    #[test]
    fn state_test() {
        let mut world = World::default();
        let mut resources = Resources::default();

        resources.insert(Vec::<&'static str>::new());
        resources.insert(State::new(my_state::S1));

        let mut stage = SystemStage::parallel();

        stage.add_system_set(State::make_driver());
        stage
            .add_system_set(
                SystemSet::default()
                    .with_system((|mut r: ResMut<Vec<&'static str>>| r.push("startup")).system())
                    .with_run_criteria(State::on_enter::<my_state::S1>()),
            )
            .add_system_set(
                SystemSet::default()
                    .with_system(
                        (|mut r: ResMut<Vec<&'static str>>, mut s: ResMut<State>| {
                            r.push("update S1");
                            s.overwrite_next(my_state::S2).unwrap();
                        })
                        .system(),
                    )
                    .with_run_criteria(State::on_update::<my_state::S1>()),
            )
            .add_system_set(
                SystemSet::default()
                    .with_system((|mut r: ResMut<Vec<&'static str>>| r.push("enter S2")).system())
                    .with_run_criteria(State::on_enter::<my_state::S2>()),
            )
            .add_system_set(
                SystemSet::default()
                    .with_system(
                        (|mut r: ResMut<Vec<&'static str>>, mut s: ResMut<State>| {
                            r.push("update S2");
                            s.overwrite_next(my_state::S3).unwrap();
                        })
                        .system(),
                    )
                    .with_run_criteria(State::on_update::<my_state::S2>()),
            )
            .add_system_set(
                SystemSet::default()
                    .with_system((|mut r: ResMut<Vec<&'static str>>| r.push("exit S2")).system())
                    .with_run_criteria(State::on_exit::<my_state::S2>()),
            )
            .add_system_set(
                SystemSet::default()
                    .with_system((|mut r: ResMut<Vec<&'static str>>| r.push("enter S3")).system())
                    .with_run_criteria(State::on_enter::<my_state::S3>()),
            )
            .add_system_set(
                SystemSet::default()
                    .with_system(
                        (|mut r: ResMut<Vec<&'static str>>, mut s: ResMut<State>| {
                            r.push("update S3");
                            s.overwrite_push(my_state::S4).unwrap();
                        })
                        .system(),
                    )
                    .with_run_criteria(State::on_update::<my_state::S3>()),
            )
            .add_system_set(
                SystemSet::default()
                    .with_system((|mut r: ResMut<Vec<&'static str>>| r.push("pause S3")).system())
                    .with_run_criteria(State::on_pause::<my_state::S3>()),
            )
            .add_system_set(
                SystemSet::default()
                    .with_system(
                        (|mut r: ResMut<Vec<&'static str>>, mut s: ResMut<State>| {
                            r.push("update S4");
                            s.overwrite_push(my_state::S5).unwrap();
                        })
                        .system(),
                    )
                    .with_run_criteria(State::on_update::<my_state::S4>()),
            )
            .add_system_set(
                SystemSet::default()
                    .with_system(
                        (|mut r: ResMut<Vec<&'static str>>| r.push("inactive S4")).system(),
                    )
                    .with_run_criteria(State::on_inactive_update::<my_state::S4>()),
            )
            .add_system_set(
                SystemSet::default()
                    .with_system(
                        (|mut r: ResMut<Vec<&'static str>>, mut s: ResMut<State>| {
                            r.push("update S5");
                            s.overwrite_push(my_state::S6).unwrap();
                        })
                        .system(),
                    )
                    .with_run_criteria(State::on_update::<my_state::S5>()),
            )
            .add_system_set(
                SystemSet::default()
                    .with_system(
                        (|mut r: ResMut<Vec<&'static str>>| r.push("inactive S5")).system(),
                    )
                    .with_run_criteria(State::on_inactive_update::<my_state::S5>()),
            )
            .add_system_set(
                SystemSet::default()
                    .with_system(
                        (|mut r: ResMut<Vec<&'static str>>, mut s: ResMut<State>| {
                            r.push("update S6");
                            s.overwrite_push(my_state::Final).unwrap();
                        })
                        .system(),
                    )
                    .with_run_criteria(State::on_update::<my_state::S6>()),
            )
            .add_system_set(
                SystemSet::default()
                    .with_system((|mut r: ResMut<Vec<&'static str>>| r.push("resume S4")).system())
                    .with_run_criteria(State::on_resume::<my_state::S4>()),
            )
            .add_system_set(
                SystemSet::default()
                    .with_system((|mut r: ResMut<Vec<&'static str>>| r.push("exit S4")).system())
                    .with_run_criteria(State::on_exit::<my_state::S5>()),
            );

        const EXPECTED: &[&[&str]] = &[
            &["startup", "update S1"],
            &["enter S2", "update S2"],
            &["exit S2", "enter S3", "update S3"],
            &["pause S3", "update S4"],
            &["inactive S4", "update S5"],
            &["inactive S4", "inactive S5", "update S6"],
            &["inactive S4", "inactive S5"],
        ];

        let mut iterator = EXPECTED.into_iter();

        loop {
            println!("new run!");
            stage.run(&mut world, &mut resources);
            let mut expected: Vec<_> = iterator.next().unwrap().into_iter().collect();
            let mut collected = resources.get_mut::<Vec<&'static str>>().unwrap();
            for found in collected.drain(..) {
                let index = expected
                    .iter()
                    .enumerate()
                    .find(|(_, &&v)| v == found)
                    .map(|(i, _)| i)
                    .expect("Unexpected execution");
                expected.swap_remove(index);
            }
            // If not zero, some elements weren't executed
            assert_eq!(expected.len(), 0);
            if resources.get::<State>().unwrap().is::<my_state::Final>() {
                break;
            }
        }
        // If not empty, some stages were skipped
        assert_eq!(iterator.next(), None);
    }
}

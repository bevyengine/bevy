use bevy_utils::HashMap;
use std::any::{Any, TypeId};
use std::marker::PhantomData;

use crate::system::{Command, IntoSystem, System};
use crate::world::{Mut, World};

/// A [`System`] that cannot be chained.
///
/// [`BoxedSystem`](crate::system::BoxedSystem) is the equivalent type alias for arbitrary `In` and `Out` types.
pub type UnchainedSystem = Box<dyn System<In = (), Out = ()>>;

/// Stores initialized [`Systems`](crate::system::System), so they can quickly be reused and run
///
/// Systems are keyed by their [`TypeId`]: repeated calls with the same function type will reuse cached state,
/// including for change detection.
/// Any [`Commands`](crate::system::Commands) generated by these systems (but not other systems), will immediately be applied.
///
/// Stored systems cannot be chained: they can neither have an [`In`](crate::system::In) nor return any values.
#[derive(Default)]
pub struct SystemRegistry {
    systems: HashMap<TypeId, UnchainedSystem>,
}

// User-facing methods
impl SystemRegistry {
    /// Registers a system in the [`SystemRegistry`], so then it can be later run.
    ///
    /// This only needs to be called manually whenn using [`run_system_by_type_id`](SystemRegistry).
    #[inline]
    pub fn register_system<Params, S: IntoSystem<(), (), Params> + 'static>(
        &mut self,
        world: &mut World,
        system: S,
    ) {
        let label = system.type_id();

        let mut unchained_system: UnchainedSystem = Box::new(IntoSystem::into_system(system));
        unchained_system.initialize(world);

        self.systems.insert(label, unchained_system);
    }

    /// Is the provided `type_id` registered?
    pub fn type_id_registered(&self, type_id: &TypeId) -> bool {
        self.systems.contains_key(type_id)
    }

    /// Runs the system corresponding to the provided [`TypeId`] on the [`World`] a single time
    pub fn run_system_by_type_id(&mut self, world: &mut World, type_id: TypeId) {
        let initialized_system = self.systems.get_mut(&type_id).unwrap_or_else(||{panic!{"No system with the `TypeId` {type_id:?} was found. Did you forget to register it?"}});
        initialized_system.run((), world);
        initialized_system.apply_buffers(world);
    }

    /// Runs the supplied system on the [`World`] a single time
    ///
    /// If `flush_commands` is true, any [`Commands`](crate::system::Commands) generated will also be applied to the world immediately
    pub fn run_system<Params, S: IntoSystem<(), (), Params> + 'static>(
        &mut self,
        world: &mut World,
        system: S,
    ) {
        let type_id = TypeId::of::<S>();
        if self.type_id_registered(&type_id) {
            self.run_system_by_type_id(world, type_id);
        } else {
            self.register_system(world, system);
            self.run_system_by_type_id(world, type_id);
        }
    }
}

impl World {
    /// Registers the supplied system in the [`SystemRegistry`] resource
    ///
    /// This allows the system to be run by [`TypeId`] using [`World::run_system_by_type_id`]
    #[inline]
    pub fn register_system<Params, S: IntoSystem<(), (), Params> + 'static>(&mut self, system: S) {
        self.resource_scope(|world, mut registry: Mut<SystemRegistry>| {
            registry.register_system(world, system);
        });
    }

    /// Runs the supplied system on the [`World`] a single time
    ///
    /// Any [`Commands`](crate::system::Commands) generated will also be applied to the world immediately.
    ///
    /// The system's state will be cached: any future calls using the same type will use this state,
    /// improving performance and ensuring that change detection works properly.
    ///
    /// Unsurprisingly, this is evaluated in a sequential, single-threaded fashion.
    /// Consider creating and running a [`Schedule`](crate::schedule::Schedule) if you need to execute large groups of systems
    /// at once, and want parallel execution of these systems.
    #[inline]
    pub fn run_system<Params, S: IntoSystem<(), (), Params> + 'static>(&mut self, system: S) {
        self.resource_scope(|world, mut registry: Mut<SystemRegistry>| {
            registry.run_system(world, system);
        });
    }

    /// Runs the system corresponding to the supplied `type_id` on the [`World`] a single time
    ///
    /// Systems must be registered before they can be run by `type_id`.
    ///
    /// Any [`Commands`](crate::system::Commands) generated will also be applied to the world immediately.
    ///
    /// The system's state will be cached: any future calls using the same type will use this state,
    /// improving performance and ensuring that change detection works properly.
    ///
    /// Unsurprisingly, this is evaluated in a sequential, single-threaded fashion.
    /// Consider creating and running a [`Schedule`](crate::schedule::Schedule) if you need to execute large groups of systems
    /// at once, and want parallel execution of these systems.
    #[inline]
    pub fn run_system_by_type_id(&mut self, type_id: TypeId) {
        self.resource_scope(|world, mut registry: Mut<SystemRegistry>| {
            registry.run_system_by_type_id(world, type_id);
        });
    }
}

/// The [`Command`] type for [`SystemRegistry::run_system`]
#[derive(Debug, Clone)]
pub struct RunSystemCommand<
    Params: Send + Sync + 'static,
    S: IntoSystem<(), (), Params> + Send + Sync + 'static,
> {
    _phantom_params: PhantomData<Params>,
    system: S,
}

impl<Params: Send + Sync + 'static, S: IntoSystem<(), (), Params> + Send + Sync + 'static>
    RunSystemCommand<Params, S>
{
    /// Creates a new [`Command`] struct, which can be addeded to [`Commands`](crate::system::Commands)
    #[inline]
    #[must_use]
    pub fn new(system: S) -> Self {
        Self {
            _phantom_params: PhantomData::default(),
            system,
        }
    }
}

impl<Params: Send + Sync + 'static, S: IntoSystem<(), (), Params> + Send + Sync + 'static> Command
    for RunSystemCommand<Params, S>
{
    #[inline]
    fn apply(self, world: &mut World) {
        if self.flush {
            world.run_system(self.system);
        } else {
            world.run_system_without_flushing(self.system);
        }
    }
}

/// The [`Command`] type for [`SystemRegistry::run_system_by_type_id`]
#[derive(Debug, Clone)]
pub struct RunSystemByTypeIdCommand {
    pub type_id: TypeId,
}

impl Command for RunSystemByTypeIdCommand {
    #[inline]
    fn write(self, world: &mut World) {
        world.run_system_by_type_id(self.type_id)
    }
}

mod tests {
    use crate::prelude::*;

    #[derive(Default, PartialEq, Debug)]
    struct Counter(u8);

    #[allow(dead_code)]
    fn count_up(mut counter: ResMut<Counter>) {
        counter.0 += 1;
    }

    #[test]
    fn run_system() {
        let mut world = World::new();
        world.init_resource::<Counter>();
        assert_eq!(*world.resource::<Counter>(), Counter(0));
        world.run_system(count_up);
        assert_eq!(*world.resource::<Counter>(), Counter(1));
    }

    #[test]
    fn run_system_by_type_id() {
        use std::any::Any;

        let mut world = World::new();
        world.init_resource::<Counter>();
        assert_eq!(*world.resource::<Counter>(), Counter(0));
        world.register_system(count_up);
        world.run_system_by_type_id(count_up.type_id());
        assert_eq!(*world.resource::<Counter>(), Counter(1));
    }

    #[allow(dead_code)]
    fn spawn_entity(mut commands: Commands) {
        commands.spawn();
    }

    #[test]
    fn command_processing() {
        let mut world = World::new();
        world.init_resource::<Counter>();
        assert_eq!(world.entities.len(), 0);
        world.run_system(spawn_entity);
        assert_eq!(world.entities.len(), 1);
    }

    fn non_send_count_down(mut ns: NonSendMut<Counter>) {
        ns.0 -= 1;
    }

    #[allow(dead_code)]
    fn trigger_non_send_count_down(mut commands: Commands) {
        commands.run_system(non_send_count_down);
    }

    #[test]
    fn non_send_resources() {
        let mut world = World::new();
        world.insert_non_send_resource(Counter(10));
        assert_eq!(*world.non_send_resource::<Counter>(), Counter(10));
        world.run_system(non_send_count_down);
        assert_eq!(*world.non_send_resource::<Counter>(), Counter(9));
        world.run_system(trigger_non_send_count_down);
        assert_eq!(*world.non_send_resource::<Counter>(), Counter(8));
    }

    #[derive(Default)]
    struct ChangeDetector;

    #[allow(dead_code)]
    fn count_up_iff_changed(mut commands: Commands, change_detector: ResMut<ChangeDetector>) {
        if change_detector.is_changed() {
            commands.run_system(count_up);
        }
    }

    #[test]
    fn change_detection() {
        let mut world = World::new();
        world.init_resource::<ChangeDetector>();
        world.init_resource::<Counter>();
        assert_eq!(*world.resource::<Counter>(), Counter(0));
        // Resources are changed when they are first added.
        world.run_system(count_up_iff_changed);
        assert_eq!(*world.resource::<Counter>(), Counter(1));
        // Nothing changed
        world.run_system(count_up_iff_changed);
        assert_eq!(*world.resource::<Counter>(), Counter(1));
        // Making a change
        world.resource_mut::<ChangeDetector>().set_changed();
        world.run_system(count_up_iff_changed);
        assert_eq!(*world.resource::<Counter>(), Counter(2));
    }

    #[allow(dead_code)]
    // The `Local` begins at the default value of 0
    fn fibonacci_counting(last_counter: Local<u8>, mut counter: ResMut<Counter>) {
        counter.0 = *last_counter + counter.0;
    }

    #[test]
    fn local_variables() {
        let mut world = World::new();
        world.insert_resource(Counter(1));
        assert_eq!(*world.resource::<Counter>(), Counter(1));
        world.run_system(fibonacci_counting);
        assert_eq!(*world.resource::<Counter>(), Counter(1));
        world.run_system(fibonacci_counting);
        assert_eq!(*world.resource::<Counter>(), Counter(2));
        world.run_system(fibonacci_counting);
        assert_eq!(*world.resource::<Counter>(), Counter(3));
        world.run_system(fibonacci_counting);
        assert_eq!(*world.resource::<Counter>(), Counter(5));
    }

    #[allow(dead_code)]
    fn count_to_ten(mut counter: ResMut<Counter>, mut commands: Commands) {
        counter.0 += 1;
        if counter.0 < 10 {
            commands.run_system(count_to_ten)
        }
    }

    #[test]
    fn system_recursion() {
        let mut world = World::new();
        world.init_resource::<Counter>();
        assert_eq!(*world.resource::<Counter>(), Counter(0));
        world.run_system(count_to_ten);
        assert_eq!(*world.resource::<Counter>(), Counter(10));
    }
}

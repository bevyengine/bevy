use bevy_utils::HashMap;

use crate::system::{BoxedSystem, Command, IntoSystem};
use crate::world::{Mut, World};
// Needed for derive(Component) macro
use crate::{self as bevy_ecs};
use bevy_ecs_macros::Resource;

/// Stores systems, so they can be reused and run in an ad-hoc fashion.
///
/// Systems are keyed by their [`SystemId`](crate::system::SystemId).
/// Repeated calls with the same function type will reuse cached state, including for change detection.
///
/// Any [`Commands`](crate::system::Commands) generated by these systems (but not other systems), will immediately be applied.
///
/// This type is stored as a [`Resource`](crate::system::Resource) on each [`World`], initialized by default.
/// However, it will likely be easier to use the corresponding methods on [`World`],
/// to avoid having to worry about split mutable borrows yourself.
///
/// # Limitations
///
///  - Stored systems cannot be chained: they can neither have an [`In`](crate::system::In) nor return any values.
///  - Stored systems cannot recurse or nest: they cannot run other systems via
///    the [`SystemRegistry`](crate::system::SystemRegistry) methods on [`World`] or [`Commands`](crate::system::Commands).
///  - Exclusive systems cannot be used.
/// # Examples
///
/// You can run a single system directly on the [`World`], while maintaining state.
/// It's also possible to register two systems at once.
///
/// ```rust
/// # use bevy_ecs::prelude::*;
/// #[derive(Resource, Default)]
/// struct Counter(u8);
///
/// fn increment(mut counter: Local<Counter>) {
///    counter.0 += 1;
///    println!("{}", counter.0);
/// }
///
/// let mut world = World::default();
/// let counter_one = world.register_system(increment);
/// let counter_two = world.register_system(increment);
/// world.run_system_by_id(counter_one); // -> 1
/// world.run_system_by_id(counter_one); // -> 2
/// world.run_system_by_id(counter_two); // -> 1
/// ```
///
/// Change detection:
///
/// ```rust
/// # use bevy_ecs::prelude::*;
/// #[derive(Resource, Default)]
/// struct ChangeDetector;
///
/// let mut world = World::default();
/// world.init_resource::<ChangeDetector>();
/// let detector = world.register_system(|change_detector: ResMut<ChangeDetector>| {
///     if change_detector.is_changed() {
///         println!("Something happened!");
///     } else {
///         println!("Nothing happened.");
///     }
/// });
///
/// // Resources are changed when they are first added
/// let _ = world.run_system_by_id(detector); // -> Something happened!
/// let _ = world.run_system_by_id(detector); // -> Nothing happened.
/// world.resource_mut::<ChangeDetector>().set_changed();
/// let _ = world.run_system_by_id(detector); // -> Something happened!
/// ```
#[derive(Resource, Default)]
pub struct SystemRegistry {
    last_id: u32,
    systems: HashMap<u32, RegisteredSystem>,
}

/// A small wrapper for [`BoxedSystem`] that also keeps track whether or not the system has been initialized.
///
/// The [`SystemRegistry`] stores systems in this format.
pub struct RegisteredSystem {
    /// Shows whether or not the system is initialized.
    pub initialized: bool,
    /// The system stored in the [`SystemRegistry`].
    pub system: BoxedSystem,
}

/// An identifier for a system registered in the [`SystemRegistry`].
///
/// These are opaque identifiers, keyed to a specific [`SystemRegistry`],
/// and are created via [`SystemRegistry::register`].
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct SystemId(u32);

impl SystemRegistry {
    /// Registers a system in the [`SystemRegistry`], so it can be run later.
    ///
    /// It's possible to register the same system twice, creating two or more distinct instances in the registry.
    #[inline]
    pub fn register<M, S: IntoSystem<(), (), M> + 'static>(&mut self, system: S) -> SystemId {
        let id = self
            .last_id
            .checked_add(1)
            .expect("Maximum number of registered systems exceeded.");
        self.last_id = id;
        let registered_system = RegisteredSystem {
            initialized: false,
            system: Box::new(IntoSystem::into_system(system)),
        };
        self.systems.insert(id, registered_system);
        SystemId(id)
    }

    /// Removes a registered system from the [`SystemRegistry`], if the [`SystemId`] is not
    /// registered, it returns [`None`], otherwise it returns the system.
    #[inline]
    pub fn remove(&mut self, id: SystemId) -> Option<RegisteredSystem> {
        self.systems.remove(&id.0)
    }

    /// Run the system by its [`SystemId`].
    ///
    /// A [`SystemId`] can be obtained by registering it first via [`SystemRegistry::register`].
    #[inline]
    pub fn run_by_id(
        &mut self,
        world: &mut World,
        id: SystemId,
    ) -> Result<(), SystemRegistryError> {
        match self.systems.get_mut(&id.0) {
            Some(RegisteredSystem {
                initialized,
                system,
            }) => {
                if !*initialized {
                    system.initialize(world);
                    *initialized = true;
                }
                system.run((), world);
                system.apply_deferred(world);
                Ok(())
            }
            None => Err(SystemRegistryError::SystemIdNotRegistered(id)),
        }
    }
}

impl World {
    /// Registers a system in the [`SystemRegistry`].
    ///
    /// Calls [`SystemRegistry::register`].
    #[inline]
    pub fn register_system<M, S: IntoSystem<(), (), M> + 'static>(
        &mut self,
        system: S,
    ) -> SystemId {
        if !self.contains_resource::<SystemRegistry>() {
            panic!(
                "SystemRegistry not found: Nested and recursive one-shot systems are not supported"
            );
        }

        self.resource_mut::<SystemRegistry>().register(system)
    }

    /// Removes a registered system in the [`SystemRegistry`] and returns the system if it exists.
    ///
    /// Calls [`SystemRegistry::remove`].
    #[inline]
    pub fn remove_system(&mut self, id: SystemId) -> Option<RegisteredSystem> {
        if !self.contains_resource::<SystemRegistry>() {
            panic!(
                "SystemRegistry not found: Nested and recursive one-shot systems are not supported"
            );
        }

        self.resource_mut::<SystemRegistry>().remove(id)
    }

    /// Run the systems with the provided [`SystemId`].
    /// A [`SystemId`] can obtained by registering a system via `[world::register_system]`.
    ///
    /// Calls [`SystemRegistry::run_by_id`].
    #[inline]
    pub fn run_system_by_id(&mut self, id: SystemId) -> Result<(), SystemRegistryError> {
        if !self.contains_resource::<SystemRegistry>() {
            panic!(
                "SystemRegistry not found: Nested and recursive one-shot systems are not supported"
            );
        }

        self.resource_scope(|world, mut registry: Mut<SystemRegistry>| {
            registry.run_by_id(world, id)
        })
    }
}

/// The [`Command`] type for [`SystemRegistry::run_by_id`].
#[derive(Debug, Clone)]
pub struct RunSystemById {
    system_id: SystemId,
}

impl RunSystemById {
    /// Creates a new [`Command`] struct, which can be added to [`Commands`](crate::system::Commands)
    pub fn new(system_id: SystemId) -> Self {
        Self { system_id }
    }
}

impl Command for RunSystemById {
    #[inline]
    fn apply(self, world: &mut World) {
        if !world.contains_resource::<SystemRegistry>() {
            panic!(
                "SystemRegistry not found: Nested and recursive one-shot systems are not supported"
            );
        }

        world.resource_scope(|world, mut registry: Mut<SystemRegistry>| {
            registry
                .run_by_id(world, self.system_id)
                // Ideally this error should be handled more gracefully,
                // but that's blocked on a full error handling solution for commands
                .unwrap();
        });
    }
}

/// An operation on a [`SystemRegistry`] failed
#[derive(Debug)]
pub enum SystemRegistryError {
    /// A system was run by label, but no system with that label was found.
    ///
    /// Did you forget to register it?
    SystemIdNotRegistered(SystemId),
}

mod tests {
    use crate as bevy_ecs;
    use crate::prelude::*;

    #[derive(Resource, Default, PartialEq, Debug)]
    struct Counter(u8);

    #[test]
    fn change_detection() {
        #[derive(Resource, Default)]
        struct ChangeDetector;

        fn count_up_iff_changed(
            mut counter: ResMut<Counter>,
            change_detector: ResMut<ChangeDetector>,
        ) {
            if change_detector.is_changed() {
                counter.0 += 1;
            }
        }

        let mut world = World::new();
        world.init_resource::<ChangeDetector>();
        world.init_resource::<Counter>();
        assert_eq!(*world.resource::<Counter>(), Counter(0));
        // Resources are changed when they are first added.
        let id = world.register_system(count_up_iff_changed);
        let _ = world.run_system_by_id(id);
        assert_eq!(*world.resource::<Counter>(), Counter(1));
        // Nothing changed
        let _ = world.run_system_by_id(id);
        assert_eq!(*world.resource::<Counter>(), Counter(1));
        // Making a change
        world.resource_mut::<ChangeDetector>().set_changed();
        let _ = world.run_system_by_id(id);
        assert_eq!(*world.resource::<Counter>(), Counter(2));
    }

    #[test]
    fn local_variables() {
        // The `Local` begins at the default value of 0
        fn doubling(last_counter: Local<Counter>, mut counter: ResMut<Counter>) {
            counter.0 += last_counter.0 .0;
            last_counter.0 .0 = counter.0;
        }

        let mut world = World::new();
        world.insert_resource(Counter(1));
        assert_eq!(*world.resource::<Counter>(), Counter(1));
        let id = world.register_system(doubling);
        let _ = world.run_system_by_id(id);
        assert_eq!(*world.resource::<Counter>(), Counter(1));
        let _ = world.run_system_by_id(id);
        assert_eq!(*world.resource::<Counter>(), Counter(2));
        let _ = world.run_system_by_id(id);
        assert_eq!(*world.resource::<Counter>(), Counter(4));
        let _ = world.run_system_by_id(id);
        assert_eq!(*world.resource::<Counter>(), Counter(8));
    }
}

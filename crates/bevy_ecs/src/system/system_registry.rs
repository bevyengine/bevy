use bevy_utils::HashMap;
use std::marker::PhantomData;

use crate::archetype::ArchetypeGeneration;
use crate::schedule::SystemLabel;
use crate::system::{Command, IntoSystem, System, SystemTypeIdLabel};
use crate::world::{Mut, World};

/// Stores initialized [`Systems`](crate::system::System), so they can be reused and run in an ad-hoc fashion
///
/// Systems are keyed by their [`SystemLabel`]:
///  - all systems with a given label will be run (in linear registration order) when a given label is run
///  - repeated calls with the same function type will reuse cached state, including for change detection
///
/// Any [`Commands`](crate::system::Commands) generated by these systems (but not other systems), will immediately be applied.
///
/// Stored systems cannot be chained: they can neither have an [`In`](crate::system::In) nor return any values.
#[derive(Default)]
pub struct SystemRegistry {
    systems: Vec<StoredSystem>,
    // Stores the index of all systems that match the key's label
    labels: HashMap<Box<dyn SystemLabel>, Vec<usize>>,
}

struct StoredSystem {
    system: Box<dyn System<In = (), Out = ()>>,
    generation: ArchetypeGeneration,
}

impl StoredSystem {
    /// Updates archetypes to ensure our access pointers are correct
    ///
    /// This logic must be run after each system is run, as each system can modify archetypes
    // TODO: remove this method once https://github.com/bevyengine/bevy/pull/4115 is merged
    fn update_archetypes(&mut self, world: &mut World) {
        // This logic is borrowed directly from SingleThreadedExecutor
        let archetypes = world.archetypes();
        let new_generation = archetypes.generation();
        let old_generation = std::mem::replace(&mut self.generation, new_generation);
        self.generation = new_generation;

        let archetype_index_range = old_generation.value()..new_generation.value();

        for archetype in archetypes.archetypes[archetype_index_range].iter() {
            self.system.new_archetype(archetype);
        }
    }
}

impl SystemRegistry {
    /// Registers a system in the [`SystemRegistry`], so then it can be later run.
    ///
    /// This method only needs to be called manually when using [`run_system_by_label`](SystemRegistry).
    ///
    /// If `labels` are provided, the system will be registered under those labels.
    /// Otherwise, it will use the default labels for that system, typically its [`SystemTypeIdLabel`].
    #[inline]
    pub fn register_system<Params, S: IntoSystem<(), (), Params> + 'static>(
        &mut self,
        world: &mut World,
        system: S,
        labels: Option<Vec<Box<dyn SystemLabel>>>,
    ) {
        let mut unchained_system: Box<dyn System<In = (), Out = ()>> =
            Box::new(IntoSystem::into_system(system));

        // If no labels are provided, use the default labels
        let labels = labels.unwrap_or(unchained_system.default_labels());

        // Intialize the system's state
        unchained_system.initialize(world);
        // Record the archetype generation at the time of its creation
        let archetype_generation = ArchetypeGeneration::initial();

        let stored_system = StoredSystem {
            system: unchained_system,
            generation: archetype_generation,
        };

        // Add the system to the end of the vec
        self.systems.push(stored_system);
        let system_index = self.systems.len();

        // For each label that the system has
        for label in labels {
            let maybe_label_indexes = self.labels.get_mut(&label);

            // Add the index of the system in the vec to the lookup hashmap
            // under the corresponding label key
            if let Some(label_indexes) = maybe_label_indexes {
                label_indexes.push(system_index);
            } else {
                self.labels.insert(label, vec![system_index]);
            };
        }
    }

    /// Returns true if at least one system in the [`SystemRegistry`] is associated with the provided [`SystemLabel`].
    pub fn label_registered<L: SystemLabel>(&self, label: L) -> bool {
        let boxed_label: Box<dyn SystemLabel> = Box::new(label);
        self.labels.get(&boxed_label).is_some()
    }

    /// Runs the set of systems corresponding to the provided [`SystemLabel`] on the [`World`] a single time
    ///
    /// Systems will be run sequentially in registration order if more than one registered system matches the provided label
    pub fn run_systems_by_label<L: SystemLabel + ?Sized>(&mut self, world: &mut World, label: &L) {
        let boxed_label: Box<dyn SystemLabel> = label.dyn_clone();

        let matching_system_indexes = self.labels.get(&boxed_label).unwrap_or_else(||{panic!{"No system with the `SystemLabel` {label:?} was found. Did you forget to register it?"}});

        // Loop over the system in registration order
        for &index in matching_system_indexes {
            let ref mut stored_system = self.systems[index];
            // Update the archetypes to make sure our data access is correct
            stored_system.update_archetypes(world);
            // Run the system
            stored_system.system.run((), world);
            // Apply any generated commands
            stored_system.system.apply_buffers(world);
        }
    }

    /// Runs the supplied system on the [`World`] a single time
    ///
    /// If `flush_commands` is true, any [`Commands`](crate::system::Commands) generated will also be applied to the world immediately
    pub fn run_system<Params, S: IntoSystem<(), (), Params> + 'static>(
        &mut self,
        world: &mut World,
        system: S,
    ) {
        let automatic_system_label: SystemTypeIdLabel<S> = SystemTypeIdLabel::new();

        if self.label_registered(automatic_system_label) {
            self.run_systems_by_label(world, &automatic_system_label);
        } else {
            self.register_system(world, system, None);
            self.run_systems_by_label(world, &automatic_system_label);
        }
    }
}

impl World {
    /// Registers the supplied system in the [`SystemRegistry`] resource
    ///
    /// This allows the system to be run by their [`SystemLabel`] using [`World::run_systems_by_label`]
    #[inline]
    pub fn register_system<Params, S: IntoSystem<(), (), Params> + 'static>(
        &mut self,
        system: S,
        labels: Option<Vec<Box<dyn SystemLabel>>>,
    ) {
        self.resource_scope(|world, mut registry: Mut<SystemRegistry>| {
            registry.register_system(world, system, labels);
        });
    }

    /// Runs the supplied system on the [`World`] a single time
    ///
    /// Any [`Commands`](crate::system::Commands) generated will also be applied to the world immediately.
    ///
    /// The system's state will be cached: any future calls using the same type will use this state,
    /// improving performance and ensuring that change detection works properly.
    ///
    /// This is evaluated in a sequential, single-threaded fashion.
    /// Consider creating and running a [`Schedule`](crate::schedule::Schedule) if you need to execute large groups of systems
    /// at once, and want parallel execution of these systems.
    #[inline]
    pub fn run_system<Params, S: IntoSystem<(), (), Params> + 'static>(&mut self, system: S) {
        self.resource_scope(|world, mut registry: Mut<SystemRegistry>| {
            registry.run_system(world, system);
        });
    }

    /// Runs the system corresponding to the supplied [`SystemLabel`] on the [`World`] a single time
    ///
    /// Systems must be registered before they can be run by their label.
    ///
    /// Any [`Commands`](crate::system::Commands) generated will also be applied to the world immediately.
    ///
    /// The system's state will be cached: any future calls using the same type will use this state,
    /// improving performance and ensuring that change detection works properly.
    ///
    /// This is evaluated in a sequential, single-threaded fashion.
    /// Consider creating and running a [`Schedule`](crate::schedule::Schedule) if you need to execute large groups of systems
    /// at once, and want parallel execution of these systems.
    #[inline]
    pub fn run_systems_by_label<L: SystemLabel + ?Sized>(&mut self, label: &L) {
        self.resource_scope(|world, mut registry: Mut<SystemRegistry>| {
            registry.run_systems_by_label(world, label);
        });
    }
}

/// The [`Command`] type for [`SystemRegistry::run_system`]
#[derive(Debug, Clone)]
pub struct RunSystemCommand<
    Params: Send + Sync + 'static,
    S: IntoSystem<(), (), Params> + Send + Sync + 'static,
> {
    _phantom_params: PhantomData<Params>,
    system: S,
}

impl<Params: Send + Sync + 'static, S: IntoSystem<(), (), Params> + Send + Sync + 'static>
    RunSystemCommand<Params, S>
{
    /// Creates a new [`Command`] struct, which can be added to [`Commands`](crate::system::Commands)
    #[inline]
    #[must_use]
    pub fn new(system: S) -> Self {
        Self {
            _phantom_params: PhantomData::default(),
            system,
        }
    }
}

impl<Params: Send + Sync + 'static, S: IntoSystem<(), (), Params> + Send + Sync + 'static> Command
    for RunSystemCommand<Params, S>
{
    #[inline]
    fn apply(self, world: &mut World) {
        if self.flush {
            world.run_system(self.system);
        } else {
            world.run_system_without_flushing(self.system);
        }
    }
}

/// The [`Command`] type for [`SystemRegistry::run_systems_by_label`]
#[derive(Debug, Clone)]
pub struct RunSystemsByLabelCommand {
    pub label: Box<dyn SystemLabel>,
}

impl Command for RunSystemsByLabelCommand {
    #[inline]
    fn write(self, world: &mut World) {
        world.run_systems_by_label(&*self.label)
    }
}

mod tests {
    use crate::prelude::*;

    #[derive(Default, PartialEq, Debug)]
    struct Counter(u8);

    #[allow(dead_code)]
    fn count_up(mut counter: ResMut<Counter>) {
        counter.0 += 1;
    }

    #[test]
    fn run_system() {
        let mut world = World::new();
        world.init_resource::<Counter>();
        assert_eq!(*world.resource::<Counter>(), Counter(0));
        world.run_system(count_up);
        assert_eq!(*world.resource::<Counter>(), Counter(1));
    }

    #[test]
    fn run_system_by_label() {
        use crate::system::AsSystemLabel;

        let mut world = World::new();
        world.init_resource::<Counter>();
        assert_eq!(*world.resource::<Counter>(), Counter(0));
        world.register_system(count_up, None);
        world.run_systems_by_label(&count_up.as_system_label());
        assert_eq!(*world.resource::<Counter>(), Counter(1));
    }

    #[allow(dead_code)]
    fn spawn_entity(mut commands: Commands) {
        commands.spawn();
    }

    #[test]
    fn command_processing() {
        let mut world = World::new();
        world.init_resource::<Counter>();
        assert_eq!(world.entities.len(), 0);
        world.run_system(spawn_entity);
        assert_eq!(world.entities.len(), 1);
    }

    fn non_send_count_down(mut ns: NonSendMut<Counter>) {
        ns.0 -= 1;
    }

    #[allow(dead_code)]
    fn trigger_non_send_count_down(mut commands: Commands) {
        commands.run_system(non_send_count_down);
    }

    #[test]
    fn non_send_resources() {
        let mut world = World::new();
        world.insert_non_send_resource(Counter(10));
        assert_eq!(*world.non_send_resource::<Counter>(), Counter(10));
        world.run_system(non_send_count_down);
        assert_eq!(*world.non_send_resource::<Counter>(), Counter(9));
        world.run_system(trigger_non_send_count_down);
        assert_eq!(*world.non_send_resource::<Counter>(), Counter(8));
    }

    #[derive(Default)]
    struct ChangeDetector;

    #[allow(dead_code)]
    fn count_up_iff_changed(mut commands: Commands, change_detector: ResMut<ChangeDetector>) {
        if change_detector.is_changed() {
            commands.run_system(count_up);
        }
    }

    #[test]
    fn change_detection() {
        let mut world = World::new();
        world.init_resource::<ChangeDetector>();
        world.init_resource::<Counter>();
        assert_eq!(*world.resource::<Counter>(), Counter(0));
        // Resources are changed when they are first added.
        world.run_system(count_up_iff_changed);
        assert_eq!(*world.resource::<Counter>(), Counter(1));
        // Nothing changed
        world.run_system(count_up_iff_changed);
        assert_eq!(*world.resource::<Counter>(), Counter(1));
        // Making a change
        world.resource_mut::<ChangeDetector>().set_changed();
        world.run_system(count_up_iff_changed);
        assert_eq!(*world.resource::<Counter>(), Counter(2));
    }

    #[allow(dead_code)]
    // The `Local` begins at the default value of 0
    fn fibonacci_counting(last_counter: Local<u8>, mut counter: ResMut<Counter>) {
        counter.0 = *last_counter + counter.0;
    }

    #[test]
    fn local_variables() {
        let mut world = World::new();
        world.insert_resource(Counter(1));
        assert_eq!(*world.resource::<Counter>(), Counter(1));
        world.run_system(fibonacci_counting);
        assert_eq!(*world.resource::<Counter>(), Counter(1));
        world.run_system(fibonacci_counting);
        assert_eq!(*world.resource::<Counter>(), Counter(2));
        world.run_system(fibonacci_counting);
        assert_eq!(*world.resource::<Counter>(), Counter(3));
        world.run_system(fibonacci_counting);
        assert_eq!(*world.resource::<Counter>(), Counter(5));
    }

    #[allow(dead_code)]
    fn count_to_ten(mut counter: ResMut<Counter>, mut commands: Commands) {
        counter.0 += 1;
        if counter.0 < 10 {
            commands.run_system(count_to_ten)
        }
    }

    #[test]
    fn system_recursion() {
        let mut world = World::new();
        world.init_resource::<Counter>();
        assert_eq!(*world.resource::<Counter>(), Counter(0));
        world.run_system(count_to_ten);
        assert_eq!(*world.resource::<Counter>(), Counter(10));
    }
}

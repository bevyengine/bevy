use bevy_utils::HashMap;
use std::marker::PhantomData;

use crate::archetype::ArchetypeGeneration;
use crate::schedule::SystemLabel;
use crate::system::{Command, IntoSystem, System, SystemTypeIdLabel};
use crate::world::{Mut, World};

/// Stores initialized [`Systems`](crate::system::System), so they can be reused and run in an ad-hoc fashion
///
/// Systems are keyed by their [`SystemLabel`]:
///  - all systems with a given label will be run (in linear registration order) when a given label is run
///  - repeated calls with the same function type will reuse cached state, including for change detection
///
/// Any [`Commands`](crate::system::Commands) generated by these systems (but not other systems), will immediately be applied.
///
/// Stored systems cannot be chained: they can neither have an [`In`](crate::system::In) nor return any values.
///
/// # Examples
///
/// You can run a single system directly on the World,
/// applying its effect and caching its state for the next time
/// you call this method (internally, this is based on [`SystemTypeIdLabel`]).
///
/// ```rust
/// use bevy_ecs::prelude::*;
///
/// let mut world = World::new();  
///
/// #[derive(Default, PartialEq, Debug)]
/// struct Counter(u8);
///
/// fn count_up(mut counter: ResMut<Counter>){
///     counter.0 += 1;
/// }
///
/// world.init_resource::<Counter>();
/// world.run_system(count_up);
///
/// assert_eq!(Counter(1), *world.resource());
/// ```
///
/// These systems immediately apply commands and cache state,
/// ensuring that change detection and [`Local`](crate::system::Local) variables work correctly.
///
/// ```rust
/// use bevy_ecs::prelude::*;
///
/// let mut world = World::new();
///
/// #[derive(Component)]
/// struct Marker;
///
/// fn spawn_7_entities(mut commands: Commands) {
///     for _ in 0..7 {
///         commands.spawn().insert(Marker);
///     }
///     
///     // You can even run systems via commands,
///     // which will take effect the next time commands are applied
///     commands.run_system(assert_7_spawned)
/// }
///
/// fn assert_7_spawned(query: Query<(), Added<Marker>>){
///     let n_spawned = query.iter().count();
///     assert_eq!(n_spawned, 7);
/// }
///
/// world.run_system(spawn_7_entities);
/// ```
///
/// ```rust
/// use bevy_ecs::prelude::*;
/// use bevy_ecs::system::SystemRegistry;
///
/// let mut world = World::new();
/// // The `SystemRegistry` type is automatically included as a resource in every World
/// let mut system_registry: Mut<SystemRegistry> = world.resource_mut();
///
/// #[derive(SystemLabel, Debug, PartialEq, Eq, Hash, Clone)]
/// enum ManualSystems {
///     Hello,
///     Goodbye,
/// }
///
/// fn hello(){
///     println!("Hello!")
/// }
///
/// fn goodbye(){
///     println!("Goodbye <3")
/// }
///
/// fn have_a_nice_day(){
///     println!("Have a nice day, and enjoy using Bevy!")
/// }
///
/// // You can register systems by their label
/// system_registry.register_system(&mut world, hello, vec![ManualSystems::Hello]);
///
/// // And run them by their label as well
/// system_registry.run_systems_by_label(&mut world, &ManualSystems::Hello);
///
/// // All systems registered under that label will be run, in registration order
/// system_registry.register_system(&mut world, hello, vec![ManualSystems::Hello]);
/// system_registry.run_systems_by_label(&mut world, &ManualSystems::Hello);
///
/// // All methods on this type are also exposed on the `World` for convenience
/// world.register_system(goodbye, vec![ManualSystems::Goodbye]);
/// world.register_system(have_a_nice_day, vec![ManualSystems::Goodbye]);
/// world.run_systems_by_label(&ManualSystems::Goodbye);
/// ```
#[derive(Default)]
pub struct SystemRegistry {
    systems: Vec<StoredSystem>,
    // Stores the index of all systems that match the key's label
    labels: HashMap<Box<dyn SystemLabel>, Vec<usize>>,
}

struct StoredSystem {
    system: Box<dyn System<In = (), Out = ()>>,
    generation: ArchetypeGeneration,
}

impl StoredSystem {
    /// Updates archetypes to ensure our access pointers are correct
    ///
    /// This logic must be run after each system is run, as each system can modify archetypes
    // TODO: remove this method once https://github.com/bevyengine/bevy/pull/4115 is merged
    fn update_archetypes(&mut self, world: &mut World) {
        // This logic is borrowed directly from SingleThreadedExecutor
        let archetypes = world.archetypes();
        let new_generation = archetypes.generation();
        let old_generation = std::mem::replace(&mut self.generation, new_generation);
        self.generation = new_generation;

        let archetype_index_range = old_generation.value()..new_generation.value();

        for archetype in archetypes.archetypes[archetype_index_range].iter() {
            self.system.new_archetype(archetype);
        }
    }
}

impl SystemRegistry {
    /// Registers a system in the [`SystemRegistry`], so then it can be later run.
    ///
    /// This method only needs to be called manually when using [`run_system_by_label`](SystemRegistry).
    ///
    /// If `labels` are provided, the system will be registered under those labels.
    /// Otherwise, it will use the default labels for that system: typically its [`SystemTypeIdLabel`].
    #[inline]
    pub fn register_system<Params, S: IntoSystem<(), (), Params> + 'static>(
        &mut self,
        world: &mut World,
        system: S,
        labels: impl IntoIterator<Item = Box<dyn SystemLabel>>,
    ) {
        let boxed_system: Box<dyn System<In = (), Out = ()>> =
            Box::new(IntoSystem::into_system(system));

        let mut labels: Vec<Box<dyn SystemLabel>> = labels.into_iter().collect();

        // If no labels are provided, use the default labels
        if labels.is_empty() {
            labels = boxed_system.default_labels()
        }

        self.register_boxed_system_by_labels(world, boxed_system, labels);
    }

    /// A more effecient but less ergonomic version of `register_system`
    pub fn register_boxed_system_by_labels(
        &mut self,
        world: &mut World,
        mut boxed_system: Box<dyn System<In = (), Out = ()>>,
        labels: Vec<Box<dyn SystemLabel>>,
    ) {
        // Intialize the system's state
        boxed_system.initialize(world);
        // Record the archetype generation at the time of its creation
        let archetype_generation = ArchetypeGeneration::initial();

        let stored_system = StoredSystem {
            system: boxed_system,
            generation: archetype_generation,
        };

        // Add the system to the end of the vec
        self.systems.push(stored_system);
        let system_index = self.systems.len();

        // For each label that the system has
        for label in labels {
            let maybe_label_indexes = self.labels.get_mut(&label);

            // Add the index of the system in the vec to the lookup hashmap
            // under the corresponding label key
            if let Some(label_indexes) = maybe_label_indexes {
                label_indexes.push(system_index);
            } else {
                self.labels.insert(label, vec![system_index]);
            };
        }
    }

    /// Runs the system at the supplied `index` a single time
    #[inline]
    fn run_system_at_index(&mut self, world: &mut World, index: usize) {
        let ref mut stored_system = self.systems[index];

        // Update the archetypes to make sure our data access is correct
        stored_system.update_archetypes(world);
        // Run the system
        stored_system.system.run((), world);
        // Apply any generated commands
        stored_system.system.apply_buffers(world);
    }

    /// Returns true if at least one system in the [`SystemRegistry`] is associated with the provided [`SystemLabel`].
    #[inline]
    pub fn label_registered<L: SystemLabel>(&self, label: L) -> bool {
        let boxed_label: Box<dyn SystemLabel> = Box::new(label);
        self.labels.get(&boxed_label).is_some()
    }

    /// Returns the first matching index for systems with this label
    ///
    /// # Panics
    ///
    /// Panics if no system with the label is registered.
    #[inline]
    fn first_registered_index<L: SystemLabel>(&self, label: L) -> usize {
        let boxed_label: Box<dyn SystemLabel> = Box::new(label);
        let vec_of_indexes = self.labels.get(&boxed_label).unwrap();
        *vec_of_indexes.iter().next().unwrap()
    }

    /// Runs the set of systems corresponding to the provided [`SystemLabel`] on the [`World`] a single time
    ///
    /// Systems will be run sequentially in registration order if more than one registered system matches the provided label
    pub fn run_systems_by_label<L: SystemLabel + ?Sized>(&mut self, world: &mut World, label: &L) {
        let boxed_label: Box<dyn SystemLabel> = label.dyn_clone();

        let matching_system_indexes = self.labels.get(&boxed_label).unwrap_or_else(||{panic!{"No system with the `SystemLabel` {label:?} was found. Did you forget to register it?"}});

        // Loop over the system in registration order
        for index in matching_system_indexes.clone() {
            self.run_system_at_index(world, index);
        }
    }

    /// Runs the supplied system on the [`World`] a single time
    ///
    /// System state will be reused between runs, ensuring that [`Local`](crate::system::Local) variables and change detection works correctly.
    /// If, via manual system registration, you have somehow managed to insert more than one system with the same [`SystemTypeIdLabel`],
    /// only the first will be run.
    pub fn run_system<Params, S: IntoSystem<(), (), Params> + 'static>(
        &mut self,
        world: &mut World,
        system: S,
    ) {
        let automatic_system_label: SystemTypeIdLabel<S> = SystemTypeIdLabel::new();

        if !self.label_registered(automatic_system_label) {
            let boxed_system: Box<dyn System<In = (), Out = ()>> =
                Box::new(IntoSystem::into_system(system));
            let labels = boxed_system.default_labels();
            self.register_boxed_system_by_labels(world, boxed_system, labels);
        }
        self.run_system_at_index(world, self.first_registered_index(automatic_system_label));
    }
}

impl World {
    /// Registers the supplied system in the [`SystemRegistry`] resource
    ///
    /// This allows the system to be run by their [`SystemLabel`] using [`World::run_systems_by_label`]
    #[inline]
    pub fn register_system<Params, S: IntoSystem<(), (), Params> + 'static>(
        &mut self,
        system: S,
        labels: Vec<Box<dyn SystemLabel>>,
    ) {
        self.resource_scope(|world, mut registry: Mut<SystemRegistry>| {
            registry.register_system(world, system, labels);
        });
    }

    /// Runs the supplied system on the [`World`] a single time
    ///
    /// Any [`Commands`](crate::system::Commands) generated will also be applied to the world immediately.
    ///
    /// The system's state will be cached: any future calls using the same type will use this state,
    /// improving performance and ensuring that change detection works properly.
    ///
    /// This is evaluated in a sequential, single-threaded fashion.
    /// Consider creating and running a [`Schedule`](crate::schedule::Schedule) if you need to execute large groups of systems
    /// at once, and want parallel execution of these systems.
    #[inline]
    pub fn run_system<Params, S: IntoSystem<(), (), Params> + 'static>(&mut self, system: S) {
        self.resource_scope(|world, mut registry: Mut<SystemRegistry>| {
            registry.run_system(world, system);
        });
    }

    /// Runs the system corresponding to the supplied [`SystemLabel`] on the [`World`] a single time
    ///
    /// Systems must be registered before they can be run by their label.
    ///
    /// Any [`Commands`](crate::system::Commands) generated will also be applied to the world immediately.
    ///
    /// The system's state will be cached: any future calls using the same type will use this state,
    /// improving performance and ensuring that change detection works properly.
    ///
    /// This is evaluated in a sequential, single-threaded fashion.
    /// Consider creating and running a [`Schedule`](crate::schedule::Schedule) if you need to execute large groups of systems
    /// at once, and want parallel execution of these systems.
    #[inline]
    pub fn run_systems_by_label<L: SystemLabel + ?Sized>(&mut self, label: &L) {
        self.resource_scope(|world, mut registry: Mut<SystemRegistry>| {
            registry.run_systems_by_label(world, label);
        });
    }
}

/// The [`Command`] type for [`SystemRegistry::run_system`]
#[derive(Debug, Clone)]
pub struct RunSystemCommand<
    Params: Send + Sync + 'static,
    S: IntoSystem<(), (), Params> + Send + Sync + 'static,
> {
    _phantom_params: PhantomData<Params>,
    system: S,
}

impl<Params: Send + Sync + 'static, S: IntoSystem<(), (), Params> + Send + Sync + 'static>
    RunSystemCommand<Params, S>
{
    /// Creates a new [`Command`] struct, which can be added to [`Commands`](crate::system::Commands)
    #[inline]
    #[must_use]
    pub fn new(system: S) -> Self {
        Self {
            _phantom_params: PhantomData::default(),
            system,
        }
    }
}

impl<Params: Send + Sync + 'static, S: IntoSystem<(), (), Params> + Send + Sync + 'static> Command
    for RunSystemCommand<Params, S>
{
    #[inline]
    fn apply(self, world: &mut World) {
        if self.flush {
            world.run_system(self.system);
        } else {
            world.run_system_without_flushing(self.system);
        }
    }
}

/// The [`Command`] type for [`SystemRegistry::run_systems_by_label`]
#[derive(Debug, Clone)]
pub struct RunSystemsByLabelCommand {
    pub label: Box<dyn SystemLabel>,
}

impl Command for RunSystemsByLabelCommand {
    #[inline]
    fn write(self, world: &mut World) {
        world.run_systems_by_label(&*self.label)
    }
}

mod tests {
    use crate::prelude::*;

    #[derive(Default, PartialEq, Debug)]
    struct Counter(u8);

    #[allow(dead_code)]
    fn count_up(mut counter: ResMut<Counter>) {
        counter.0 += 1;
    }

    #[test]
    fn run_system() {
        let mut world = World::new();
        world.init_resource::<Counter>();
        assert_eq!(*world.resource::<Counter>(), Counter(0));
        world.run_system(count_up);
        assert_eq!(*world.resource::<Counter>(), Counter(1));
    }

    #[test]
    fn run_system_by_label() {
        use crate::system::AsSystemLabel;

        let mut world = World::new();
        world.init_resource::<Counter>();
        assert_eq!(*world.resource::<Counter>(), Counter(0));
        world.register_system(count_up, Vec::default());
        world.register_system(count_up, Vec::default());
        world.run_systems_by_label(&count_up.as_system_label());
        assert_eq!(*world.resource::<Counter>(), Counter(2));
    }

    #[allow(dead_code)]
    fn spawn_entity(mut commands: Commands) {
        commands.spawn();
    }

    #[test]
    fn command_processing() {
        let mut world = World::new();
        world.init_resource::<Counter>();
        assert_eq!(world.entities.len(), 0);
        world.run_system(spawn_entity);
        assert_eq!(world.entities.len(), 1);
    }

    fn non_send_count_down(mut ns: NonSendMut<Counter>) {
        ns.0 -= 1;
    }

    #[allow(dead_code)]
    fn trigger_non_send_count_down(mut commands: Commands) {
        commands.run_system(non_send_count_down);
    }

    #[test]
    fn non_send_resources() {
        let mut world = World::new();
        world.insert_non_send_resource(Counter(10));
        assert_eq!(*world.non_send_resource::<Counter>(), Counter(10));
        world.run_system(non_send_count_down);
        assert_eq!(*world.non_send_resource::<Counter>(), Counter(9));
        world.run_system(trigger_non_send_count_down);
        assert_eq!(*world.non_send_resource::<Counter>(), Counter(8));
    }

    #[derive(Default)]
    struct ChangeDetector;

    #[allow(dead_code)]
    fn count_up_iff_changed(mut commands: Commands, change_detector: ResMut<ChangeDetector>) {
        if change_detector.is_changed() {
            commands.run_system(count_up);
        }
    }

    #[test]
    fn change_detection() {
        let mut world = World::new();
        world.init_resource::<ChangeDetector>();
        world.init_resource::<Counter>();
        assert_eq!(*world.resource::<Counter>(), Counter(0));
        // Resources are changed when they are first added.
        world.run_system(count_up_iff_changed);
        assert_eq!(*world.resource::<Counter>(), Counter(1));
        // Nothing changed
        world.run_system(count_up_iff_changed);
        assert_eq!(*world.resource::<Counter>(), Counter(1));
        // Making a change
        world.resource_mut::<ChangeDetector>().set_changed();
        world.run_system(count_up_iff_changed);
        assert_eq!(*world.resource::<Counter>(), Counter(2));
    }

    #[allow(dead_code)]
    // The `Local` begins at the default value of 0
    fn fibonacci_counting(last_counter: Local<u8>, mut counter: ResMut<Counter>) {
        counter.0 = *last_counter + counter.0;
    }

    #[test]
    fn local_variables() {
        let mut world = World::new();
        world.insert_resource(Counter(1));
        assert_eq!(*world.resource::<Counter>(), Counter(1));
        world.run_system(fibonacci_counting);
        assert_eq!(*world.resource::<Counter>(), Counter(1));
        world.run_system(fibonacci_counting);
        assert_eq!(*world.resource::<Counter>(), Counter(2));
        world.run_system(fibonacci_counting);
        assert_eq!(*world.resource::<Counter>(), Counter(3));
        world.run_system(fibonacci_counting);
        assert_eq!(*world.resource::<Counter>(), Counter(5));
    }

    #[allow(dead_code)]
    fn count_to_ten(mut counter: ResMut<Counter>, mut commands: Commands) {
        counter.0 += 1;
        if counter.0 < 10 {
            commands.run_system(count_to_ten)
        }
    }

    #[test]
    fn system_recursion() {
        let mut world = World::new();
        world.init_resource::<Counter>();
        assert_eq!(*world.resource::<Counter>(), Counter(0));
        world.run_system(count_to_ten);
        assert_eq!(*world.resource::<Counter>(), Counter(10));
    }
}

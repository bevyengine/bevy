use alloc::collections::VecDeque;
use bevy_ecs::{
    component::Component,
    entity::Entity,
    event::EntityEvent,
    hierarchy::ChildOf,
    system::{Commands, Query, ResMut},
};
use bevy_math::IVec2;
pub use cosmic_text::Motion;
use cosmic_text::{Action, BorrowedWithFontSystem, Edit, Editor, Selection};

use crate::{
    get_cosmic_text_buffer_contents, CosmicFontSystem, TextInputAttributes, TextInputBuffer,
    TextInputValue,
};

/// Text input commands queue
#[derive(Component, Default)]
pub struct TextEdits {
    /// Commands to be applied before the text input is updated
    pub queue: VecDeque<TextEdit>,
}

impl TextEdits {
    /// queue an action
    pub fn queue(&mut self, command: TextEdit) {
        self.queue.push_back(command);
    }
}

/// Deferred text input edit and navigation actions.
///
/// These are generated by user inputs,
/// stored in the [`TextEdits`] component,
/// and applied by the [`apply_text_edits`] system.
///
/// The user is currently completely responsible for generating these edits
/// by handling input events and mapping them to edits.
#[derive(Debug, Clone)]
pub enum TextEdit {
    /// Move the cursor with some motion.
    Motion {
        /// The motion to perform.
        motion: Motion,
        /// Select the text from the initial cursor position to the end of the motion.
        with_select: bool,
    },
    /// Insert a character at the cursor. If there is a selection, replaces the selection with the character instead.
    Insert(char),
    /// Set the character at the cursor, overwriting the previous character. Inserts if cursor is at the end of a line.
    /// If there is a selection, replaces the selection with the character instead.
    Overwrite(char),
    /// Insert a string at the cursor. If there is a selection, replaces the selection with the string instead.
    InsertString(String),
    /// Start a new line. Ignored for single line text inputs.
    NewLine,
    /// Delete the character behind the cursor.
    /// If there is a selection, deletes the selection instead.
    Backspace,
    /// Delete the character at the cursor.
    /// If there is a selection, deletes the selection instead.
    Delete,
    /// Indent at the cursor.
    Indent,
    /// Unindent at the cursor.
    Unindent,
    /// Moves the cursor to the character at the given position.
    Click(IVec2),
    /// Selects the word at the given position.
    DoubleClick(IVec2),
    /// Selects the line at the given position.
    TripleClick(IVec2),
    /// Select the text up to the given position
    Drag(IVec2),
    /// Scroll vertically by the given number of lines.
    /// Negative values scroll upwards towards the start of the text, positive downwards to the end of the text.
    Scroll {
        /// Number of lines to scroll.
        /// Negative values scroll upwards towards the start of the text, positive downwards to the end of the text.
        lines: i32,
    },
    /// Select the entire contents of the text input buffer.
    SelectAll,
    /// Select the line at the cursor.
    SelectLine,
    /// Clear any selection.
    Escape,
    /// Clear the text input buffer.
    Clear,
    /// Set the contents of the text input buffer. The existing contents are discarded.
    SetText(String),
}

impl TextEdit {
    /// An action that moves the cursor.
    ///
    /// If `with_select` is true, it selects as it moves.
    pub fn motion(motion: Motion, with_select: bool) -> Self {
        Self::Motion {
            motion,
            with_select,
        }
    }
}

/// apply a motion action to the editor buffer
pub fn apply_motion<'a>(
    editor: &mut BorrowedWithFontSystem<Editor<'a>>,
    shift_pressed: bool,
    motion: Motion,
) {
    if shift_pressed {
        if editor.selection() == Selection::None {
            let cursor = editor.cursor();
            editor.set_selection(Selection::Normal(cursor));
        }
    } else {
        editor.action(Action::Escape);
    }
    editor.action(Action::Motion(motion));
}

/// Returns true if the cursor is at the end of a line
pub fn is_cursor_at_end_of_line(editor: &mut Editor<'_>) -> bool {
    let cursor = editor.cursor();
    editor.with_buffer(|buffer| {
        buffer
            .lines
            .get(cursor.line)
            .map(|line| cursor.index == line.text().len())
            .unwrap_or(false)
    })
}

/// Applies the [`TextEdit`]s queued for each [`TextInputBuffer`] and emits [`TextInputEvent`]s in response.
///
/// After all edits are applied, if a text input entity has a [`TextInputValue`] component and its buffer was changed,
/// then the [`TextInputValue`]'s text is updated with the new contents of the [`TextInputBuffer`].
pub fn apply_text_edits(
    mut commands: Commands,
    mut font_system: ResMut<CosmicFontSystem>,
    mut text_input_query: Query<(
        Entity,
        &mut TextInputBuffer,
        &mut TextEdits,
        &TextInputAttributes,
        Option<&mut TextInputValue>,
    )>,
) {
    for (entity, mut buffer, mut text_input_actions, attribs, maybe_value) in
        text_input_query.iter_mut()
    {
        for edit in text_input_actions.queue.drain(..) {
            if let Err(error) = apply_text_edit(
                buffer.editor.borrow_with(&mut font_system),
                attribs.max_chars,
                &edit,
            ) {
                commands.trigger_targets(TextInputEvent::InvalidEdit(error, edit), entity);
            }
        }

        if let Some(mut value) = maybe_value {
            let contents = buffer.get_text();
            if value.0 != contents {
                value.0 = contents;
                commands.trigger_targets(TextInputEvent::TextChanged, entity);
            }
        }
    }
}

/// Error emitted by [`apply_text_edit`] when it fails to apply a [`TextEdit`].
#[derive(Debug, Clone)]
pub enum InvalidTextEditError {
    /// Applying the edit would cause the text to be longer than its maximum character limit.
    Overflowed,
}

/// Apply a text input action to a text input
pub fn apply_text_edit(
    mut editor: BorrowedWithFontSystem<'_, Editor<'static>>,
    max_chars: Option<usize>,
    edit: &TextEdit,
) -> Result<(), InvalidTextEditError> {
    editor.start_change();

    match edit {
        &TextEdit::Motion {
            motion,
            with_select,
        } => {
            apply_motion(&mut editor, with_select, motion);
        }
        TextEdit::Insert(ch) => {
            editor.action(Action::Insert(*ch));
        }
        TextEdit::InsertString(text) => {
            editor.insert_string(text, None);
        }
        &TextEdit::Overwrite(ch) => match editor.selection() {
            Selection::None => {
                if is_cursor_at_end_of_line(&mut editor) {
                    editor.action(Action::Insert(ch));
                } else {
                    editor.action(Action::Delete);
                    editor.action(Action::Insert(ch));
                }
            }
            _ => editor.action(Action::Insert(ch)),
        },
        TextEdit::NewLine => {
            editor.action(Action::Enter);
        }
        TextEdit::Backspace => {
            if !editor.delete_selection() {
                editor.action(Action::Backspace);
            }
        }
        TextEdit::Delete => {
            if !editor.delete_selection() {
                editor.action(Action::Delete);
            }
        }
        TextEdit::Indent => {
            editor.action(Action::Indent);
        }
        TextEdit::Unindent => {
            editor.action(Action::Unindent);
        }
        TextEdit::Click(point) => {
            editor.action(Action::Click {
                x: point.x,
                y: point.y,
            });
        }
        TextEdit::DoubleClick(point) => {
            editor.action(Action::DoubleClick {
                x: point.x,
                y: point.y,
            });
        }
        TextEdit::TripleClick(point) => {
            editor.action(Action::TripleClick {
                x: point.x,
                y: point.y,
            });
        }
        TextEdit::Drag(point) => {
            editor.action(Action::Drag {
                x: point.x,
                y: point.y,
            });
        }
        &TextEdit::Scroll { lines } => {
            editor.action(Action::Scroll { lines });
        }
        TextEdit::SelectAll => {
            editor.action(Action::Motion(Motion::BufferStart));
            let cursor = editor.cursor();
            editor.set_selection(Selection::Normal(cursor));
            editor.action(Action::Motion(Motion::BufferEnd));
        }
        TextEdit::SelectLine => {
            editor.action(Action::Motion(Motion::Home));
            let cursor = editor.cursor();
            editor.set_selection(Selection::Normal(cursor));
            editor.action(Action::Motion(Motion::End));
        }
        TextEdit::Escape => {
            editor.set_selection(Selection::None);
        }
        TextEdit::Clear => {
            editor.action(Action::Motion(Motion::BufferStart));
            let cursor = editor.cursor();
            editor.set_selection(Selection::Normal(cursor));
            editor.action(Action::Motion(Motion::BufferEnd));
            editor.action(Action::Delete);
        }
        TextEdit::SetText(text) => {
            editor.action(Action::Motion(Motion::Home));
            let cursor = editor.cursor();
            editor.set_selection(Selection::Normal(cursor));
            editor.action(Action::Motion(Motion::End));
            editor.insert_string(text, None);
        }
    }

    let Some(mut change) = editor.finish_change() else {
        return Ok(());
    };

    if change.items.is_empty() {
        return Ok(());
    }

    if max_chars.is_some() {
        let text = editor.with_buffer(get_cosmic_text_buffer_contents);
        if max_chars.is_some_and(|max_chars| max_chars < text.chars().count()) {
            change.reverse();
            editor.apply_change(&change);
            return Err(InvalidTextEditError::Overflowed);
        }
    }

    // Set redraw manually, sometimes the editor doesn't set it automatically.
    editor.set_redraw(true);

    Ok(())
}

/// Automatically propagated events that can be dispatched by a text input entity.
#[derive(EntityEvent, Clone, Debug, Component)]
#[entity_event(traversal = &'static ChildOf, auto_propagate)]
pub enum TextInputEvent {
    /// The text input received an invalid [`TextEdit`] that failed to be applied
    InvalidEdit(InvalidTextEditError, TextEdit),
    /// The contents of the text input changed due to a [`TextEdit`].
    /// Only dispatched if a text input entity has a [`TextInputValue`] component.
    TextChanged,
}

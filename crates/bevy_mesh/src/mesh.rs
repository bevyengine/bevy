pub use wgpu_types::PrimitiveTopology;

use super::{MeshVertexAttribute, VertexAttributeValues};
use crate::MeshExtractableData;
#[cfg(feature = "serialize")]
use crate::{Indices, MeshVertexAttributeId, SerializedMeshAttributeData};
use bevy_asset::{Asset, RenderAssetUsages};
use bevy_asset::{AssetExtractionError, ExtractableAsset, ExtractableAssetAccessError};
use bevy_math::{bounding::Aabb3d, *};
#[cfg(feature = "serialize")]
use bevy_platform::collections::HashMap;
use bevy_reflect::Reflect;
#[cfg(feature = "serialize")]
use serde::{Deserialize, Serialize};
use thiserror::Error;
use wgpu_types::VertexFormat;

pub const INDEX_BUFFER_ASSET_INDEX: u64 = 0;
pub const VERTEX_ATTRIBUTE_BUFFER_ID: u64 = 10;

/// A 3D object made out of vertices representing triangles, lines, or points,
/// with "attribute" values for each vertex.
///
/// Meshes can be automatically generated by a bevy `AssetLoader` (generally by loading a `Gltf` file),
/// or by converting a [primitive](bevy_math::primitives) using [`into`](Into).
/// It is also possible to create one manually. They can be edited after creation.
///
/// Meshes can be rendered with a [`Mesh2d`](crate::Mesh2d) and `MeshMaterial2d`
/// or [`Mesh3d`](crate::Mesh3d) and `MeshMaterial3d` for 2D and 3D respectively.
///
/// A [`Mesh`] in Bevy is equivalent to a "primitive" in the glTF format, for a
/// glTF Mesh representation, see `GltfMesh`.
///
/// ## Manual creation
///
/// The following function will construct a flat mesh, to be rendered with a
/// `StandardMaterial` or `ColorMaterial`:
///
/// ```
/// # use bevy_mesh::{Mesh, Indices, PrimitiveTopology, MeshExtractableData};
/// fn create_simple_parallelogram() -> Mesh {
///     // Create a new mesh using a triangle list topology, where each set of 3 vertices composes a triangle.
///     Mesh::from(
///         MeshExtractableData::new(PrimitiveTopology::TriangleList)
///             // Add 4 vertices, each with its own position attribute (coordinate in
///             // 3D space), for each of the corners of the parallelogram.
///             .with_inserted_attribute(
///                 Mesh::ATTRIBUTE_POSITION,
///                 vec![
///                     [0.0, 0.0, 0.0],
///                     [1.0, 2.0, 0.0],
///                     [2.0, 2.0, 0.0],
///                     [1.0, 0.0, 0.0],
///                 ],
///             )
///             // Assign a UV coordinate to each vertex.
///             .with_inserted_attribute(
///                 Mesh::ATTRIBUTE_UV_0,
///                 vec![[0.0, 1.0], [0.5, 0.0], [1.0, 0.0], [0.5, 1.0]],
///             )
///             // Assign normals (everything points outwards)
///             .with_inserted_attribute(
///                 Mesh::ATTRIBUTE_NORMAL,
///                 vec![
///                     [0.0, 0.0, 1.0],
///                     [0.0, 0.0, 1.0],
///                     [0.0, 0.0, 1.0],
///                     [0.0, 0.0, 1.0],
///                 ],
///             )
///             // After defining all the vertices and their attributes, build each triangle using the
///             // indices of the vertices that make it up in a counter-clockwise order.
///             .with_inserted_indices(Indices::U32(vec![
///                 // First triangle
///                 0, 3, 1, // Second triangle
///                 1, 3, 2,
///             ])),
///     )
/// }
/// ```
///
/// You can see how it looks like [here](https://github.com/bevyengine/bevy/blob/main/assets/docs/Mesh.png),
/// used in a [`Mesh3d`](crate::Mesh3d) with a square bevy logo texture, with added axis, points,
/// lines and text for clarity.
///
/// ## Other examples
///
/// For further visualization, explanation, and examples, see the built-in Bevy examples,
/// and the [implementation of the built-in shapes](https://github.com/bevyengine/bevy/tree/main/crates/bevy_mesh/src/primitives).
/// In particular, [generate_custom_mesh](https://github.com/bevyengine/bevy/blob/main/examples/3d/generate_custom_mesh.rs)
/// teaches you to access and modify the attributes of a [`Mesh`] after creating it.
///
/// ## Common points of confusion
///
/// - UV maps in Bevy start at the top-left, see [`ATTRIBUTE_UV_0`](Mesh::ATTRIBUTE_UV_0),
///   other APIs can have other conventions, `OpenGL` starts at bottom-left.
/// - It is possible and sometimes useful for multiple vertices to have the same
///   [position attribute](Mesh::ATTRIBUTE_POSITION) value,
///   it's a common technique in 3D modeling for complex UV mapping or other calculations.
/// - Bevy performs frustum culling based on the `Aabb` of meshes, which is calculated
///   and added automatically for new meshes only. If a mesh is modified, the entity's `Aabb`
///   needs to be updated manually or deleted so that it is re-calculated.
///
/// ## Use with `StandardMaterial`
///
/// To render correctly with `StandardMaterial`, a mesh needs to have properly defined:
/// - [`UVs`](Mesh::ATTRIBUTE_UV_0): Bevy needs to know how to map a texture onto the mesh
///   (also true for `ColorMaterial`).
/// - [`Normals`](Mesh::ATTRIBUTE_NORMAL): Bevy needs to know how light interacts with your mesh.
///   [0.0, 0.0, 1.0] is very common for simple flat meshes on the XY plane,
///   because simple meshes are smooth and they don't require complex light calculations.
/// - Vertex winding order: by default, `StandardMaterial.cull_mode` is `Some(Face::Back)`,
///   which means that Bevy would *only* render the "front" of each triangle, which
///   is the side of the triangle from where the vertices appear in a *counter-clockwise* order.
///
/// ## Remote Inspection
///
/// To transmit a [`Mesh`] between two running Bevy apps, e.g. through BRP, use [`SerializedMesh`].
/// This type is only meant for short-term transmission between same versions and should not be stored anywhere.
#[derive(Asset, Debug, Clone, Reflect, PartialEq)]
#[reflect(Clone)]
pub struct Mesh {
    #[reflect(ignore, clone)]
    primitive_topology: PrimitiveTopology,
    extractable_data: Option<MeshExtractableData>,
    pub asset_usage: RenderAssetUsages,
    /// Whether or not to build a BLAS for use with `bevy_solari` raytracing.
    ///
    /// Note that this is _not_ whether the mesh is _compatible_ with `bevy_solari` raytracing.
    /// This field just controls whether or not a BLAS gets built for this mesh, assuming that
    /// the mesh is compatible.
    ///
    /// The use case for this field is using lower-resolution proxy meshes for raytracing (to save on BLAS memory usage),
    /// while using higher-resolution meshes for raster. You can set this field to true for the lower-resolution proxy mesh,
    /// and to false for the high-resolution raster mesh.
    ///
    /// Alternatively, you can use the same mesh for both raster and raytracing, with this field set to true.
    ///
    /// Does nothing if not used with `bevy_solari`, or if the mesh is not compatible
    /// with `bevy_solari` (see `bevy_solari`'s docs).
    pub enable_raytracing: bool,
    /// Precomputed min and max extents of the mesh position data. Used mainly for constructing `Aabb`s for frustum culling.
    /// This data will be set if/when a mesh is extracted to the GPU
    pub final_aabb: Option<Aabb3d>,
}

impl From<MeshExtractableData> for Mesh {
    fn from(value: MeshExtractableData) -> Self {
        Self {
            primitive_topology: value.primitive_topology,
            extractable_data: Some(value),
            asset_usage: RenderAssetUsages::default(),
            enable_raytracing: true,
            final_aabb: None,
        }
    }
}

impl ExtractableAsset for Mesh {
    type Data = MeshExtractableData;

    fn with_extractable_data(
        mut self,
        f: impl FnOnce(Result<Self::Data, ExtractableAssetAccessError>) -> Self::Data,
    ) -> Self {
        let data = self
            .extractable_data
            .take()
            .ok_or(ExtractableAssetAccessError::ExtractedToRenderWorld);
        self.extractable_data = Some(f(data));
        self
    }

    fn extractable_data_ref(&self) -> Result<&Self::Data, ExtractableAssetAccessError> {
        self.extractable_data
            .as_ref()
            .ok_or(ExtractableAssetAccessError::ExtractedToRenderWorld)
    }

    fn extractable_data_mut(&mut self) -> Result<&mut Self::Data, ExtractableAssetAccessError> {
        self.extractable_data
            .as_mut()
            .ok_or(ExtractableAssetAccessError::ExtractedToRenderWorld)
    }

    fn take_gpu_data(&mut self) -> Result<Self, AssetExtractionError> {
        let data = self
            .extractable_data
            .take()
            .ok_or(AssetExtractionError::AlreadyExtracted)?;
        let positions = data.attribute(Mesh::ATTRIBUTE_POSITION);

        // store the aabb extents as they cannot be computed after extraction
        if let Some(VertexAttributeValues::Float32x3(position_values), ..) = positions
            && !position_values.is_empty()
        {
            let mut iter = position_values.iter().map(|p| Vec3::from_slice(p));
            let mut min = iter.next().unwrap();
            let mut max = min;
            for v in iter {
                min = Vec3::min(min, v);
                max = Vec3::max(max, v);
            }
            self.final_aabb = Some(Aabb3d::from_min_max(min, max));
        } else {
            self.final_aabb = None;
        }
        Ok(Self {
            extractable_data: Some(data),
            ..self.clone()
        })
    }
}

impl Mesh {
    /// Where the vertex is located in space. Use in conjunction with [`MeshExtractableData::insert_attribute`]
    /// or [`MeshExtractableData::with_inserted_attribute`].
    ///
    /// The format of this attribute is [`VertexFormat::Float32x3`].
    pub const ATTRIBUTE_POSITION: MeshVertexAttribute =
        MeshVertexAttribute::new("Vertex_Position", 0, VertexFormat::Float32x3);

    /// The direction the vertex normal is facing in.
    /// Use in conjunction with [`MeshExtractableData::insert_attribute`] or [`MeshExtractableData::with_inserted_attribute`].
    ///
    /// The format of this attribute is [`VertexFormat::Float32x3`].
    pub const ATTRIBUTE_NORMAL: MeshVertexAttribute =
        MeshVertexAttribute::new("Vertex_Normal", 1, VertexFormat::Float32x3);

    /// Texture coordinates for the vertex. Use in conjunction with [`MeshExtractableData::insert_attribute`]
    /// or [`MeshExtractableData::with_inserted_attribute`].
    ///
    /// Generally `[0.,0.]` is mapped to the top left of the texture, and `[1.,1.]` to the bottom-right.
    ///
    /// By default values outside will be clamped per pixel not for the vertex,
    /// "stretching" the borders of the texture.
    /// This behavior can be useful in some cases, usually when the borders have only
    /// one color, for example a logo, and you want to "extend" those borders.
    ///
    /// For different mapping outside of `0..=1` range,
    /// see [`ImageAddressMode`](bevy_image::ImageAddressMode).
    ///
    /// The format of this attribute is [`VertexFormat::Float32x2`].
    pub const ATTRIBUTE_UV_0: MeshVertexAttribute =
        MeshVertexAttribute::new("Vertex_Uv", 2, VertexFormat::Float32x2);

    /// Alternate texture coordinates for the vertex. Use in conjunction with
    /// [`MeshExtractableData::insert_attribute`] or [`MeshExtractableData::with_inserted_attribute`].
    ///
    /// Typically, these are used for lightmaps, textures that provide
    /// precomputed illumination.
    ///
    /// The format of this attribute is [`VertexFormat::Float32x2`].
    pub const ATTRIBUTE_UV_1: MeshVertexAttribute =
        MeshVertexAttribute::new("Vertex_Uv_1", 3, VertexFormat::Float32x2);

    /// The direction of the vertex tangent. Used for normal mapping.
    /// Usually generated with [`generate_tangents`](MeshExtractableData::generate_tangents) or
    /// [`with_generated_tangents`](MeshExtractableData::with_generated_tangents).
    ///
    /// The format of this attribute is [`VertexFormat::Float32x4`].
    pub const ATTRIBUTE_TANGENT: MeshVertexAttribute =
        MeshVertexAttribute::new("Vertex_Tangent", 4, VertexFormat::Float32x4);

    /// Per vertex coloring. Use in conjunction with [`MeshExtractableData::insert_attribute`]
    /// or [`MeshExtractableData::with_inserted_attribute`].
    ///
    /// The format of this attribute is [`VertexFormat::Float32x4`].
    pub const ATTRIBUTE_COLOR: MeshVertexAttribute =
        MeshVertexAttribute::new("Vertex_Color", 5, VertexFormat::Float32x4);

    /// Per vertex joint transform matrix weight. Use in conjunction with [`MeshExtractableData::insert_attribute`]
    /// or [`MeshExtractableData::with_inserted_attribute`].
    ///
    /// The format of this attribute is [`VertexFormat::Float32x4`].
    pub const ATTRIBUTE_JOINT_WEIGHT: MeshVertexAttribute =
        MeshVertexAttribute::new("Vertex_JointWeight", 6, VertexFormat::Float32x4);

    /// Per vertex joint transform matrix index. Use in conjunction with [`MeshExtractableData::insert_attribute`]
    /// or [`MeshExtractableData::with_inserted_attribute`].
    ///
    /// The format of this attribute is [`VertexFormat::Uint16x4`].
    pub const ATTRIBUTE_JOINT_INDEX: MeshVertexAttribute =
        MeshVertexAttribute::new("Vertex_JointIndex", 7, VertexFormat::Uint16x4);

    /// The first index that can be used for custom vertex attributes.
    /// Only the attributes with an index below this are used by Bevy.
    pub const FIRST_AVAILABLE_CUSTOM_ATTRIBUTE: u64 = 8;

    /// Construct a new mesh. You need to provide a [`PrimitiveTopology`] so that the
    /// renderer knows how to treat the vertex data. Most of the time this will be
    /// [`PrimitiveTopology::TriangleList`].
    pub fn new(primitive_topology: PrimitiveTopology, asset_usage: RenderAssetUsages) -> Self {
        Mesh {
            primitive_topology,
            extractable_data: Some(MeshExtractableData::new(primitive_topology)),
            asset_usage,
            enable_raytracing: true,
            final_aabb: None,
        }
    }

    /// Returns the topology of the mesh.
    pub fn primitive_topology(&self) -> PrimitiveTopology {
        self.primitive_topology
    }

    pub fn with_asset_usage(mut self, asset_usage: RenderAssetUsages) -> Self {
        self.asset_usage = asset_usage;
        self
    }
}

/// A version of [`Mesh`] suitable for serializing for short-term transfer.
///
/// [`Mesh`] does not implement [`Serialize`] / [`Deserialize`] because it is made with the renderer in mind.
/// It is not a general-purpose mesh implementation, and its internals are subject to frequent change.
/// As such, storing a [`Mesh`] on disk is highly discouraged.
///
/// But there are still some valid use cases for serializing a [`Mesh`], namely transferring meshes between processes.
/// To support this, you can create a [`SerializedMesh`] from a [`Mesh`] with [`SerializedMesh::from_mesh`],
/// and then deserialize it with [`SerializedMesh::deserialize`]. The caveats are:
/// - The mesh representation is not valid across different versions of Bevy.
/// - This conversion is lossy. Only the following information is preserved:
///   - Primitive topology
///   - Vertex attributes
///   - Indices
/// - Custom attributes that were not specified with [`MeshDeserializer::add_custom_vertex_attribute`] will be ignored while deserializing.
#[cfg(feature = "serialize")]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SerializedMesh {
    primitive_topology: PrimitiveTopology,
    attributes: Vec<(MeshVertexAttributeId, SerializedMeshAttributeData)>,
    indices: Option<Indices>,
}

#[cfg(feature = "serialize")]
impl SerializedMesh {
    /// Create a [`SerializedMesh`] from a [`Mesh`]. See the documentation for [`SerializedMesh`] for caveats.
    pub fn from_mesh(mut mesh: Mesh) -> Self {
        const MESH_EXTRACTED_ERROR: &str = "Mesh has been extracted to RenderWorld. To access vertex attributes, the mesh `asset_usage` must include `MAIN_WORLD`";
        let extractable_data = mesh.extractable_data.take().expect(MESH_EXTRACTED_ERROR);
        Self {
            primitive_topology: mesh.primitive_topology,
            attributes: extractable_data
                .attributes
                .into_iter()
                .map(|(id, data)| {
                    (
                        id,
                        SerializedMeshAttributeData::from_mesh_attribute_data(data),
                    )
                })
                .collect(),
            indices: extractable_data.indices,
        }
    }

    /// Create a [`Mesh`] from a [`SerializedMesh`]. See the documentation for [`SerializedMesh`] for caveats.
    ///
    /// Use [`MeshDeserializer`] if you need to pass extra options to the deserialization process, such as specifying custom vertex attributes.
    pub fn into_mesh(self) -> Mesh {
        MeshDeserializer::default().deserialize(self)
    }
}

/// Use to specify extra options when deserializing a [`SerializedMesh`] into a [`Mesh`].
#[cfg(feature = "serialize")]
pub struct MeshDeserializer {
    custom_vertex_attributes: HashMap<Box<str>, MeshVertexAttribute>,
}

#[cfg(feature = "serialize")]
impl Default for MeshDeserializer {
    fn default() -> Self {
        // Written like this so that the compiler can validate that we use all the built-in attributes.
        // If you just added a new attribute and got a compile error, please add it to this list :)
        const BUILTINS: [MeshVertexAttribute; Mesh::FIRST_AVAILABLE_CUSTOM_ATTRIBUTE as usize] = [
            Mesh::ATTRIBUTE_POSITION,
            Mesh::ATTRIBUTE_NORMAL,
            Mesh::ATTRIBUTE_UV_0,
            Mesh::ATTRIBUTE_UV_1,
            Mesh::ATTRIBUTE_TANGENT,
            Mesh::ATTRIBUTE_COLOR,
            Mesh::ATTRIBUTE_JOINT_WEIGHT,
            Mesh::ATTRIBUTE_JOINT_INDEX,
        ];
        Self {
            custom_vertex_attributes: BUILTINS
                .into_iter()
                .map(|attribute| (attribute.name.into(), attribute))
                .collect(),
        }
    }
}

#[cfg(feature = "serialize")]
impl MeshDeserializer {
    /// Create a new [`MeshDeserializer`].
    pub fn new() -> Self {
        Self::default()
    }

    /// Register a custom vertex attribute to the deserializer. Custom vertex attributes that were not added with this method will be ignored while deserializing.
    pub fn add_custom_vertex_attribute(
        &mut self,
        name: &str,
        attribute: MeshVertexAttribute,
    ) -> &mut Self {
        self.custom_vertex_attributes.insert(name.into(), attribute);
        self
    }

    /// Deserialize a [`SerializedMesh`] into a [`Mesh`].
    ///
    /// See the documentation for [`SerializedMesh`] for caveats.
    pub fn deserialize(&self, serialized_mesh: SerializedMesh) -> Mesh {
        let attributes = serialized_mesh
            .attributes
            .into_iter()
            .filter_map(|(id, data)| {
                let attribute = data.attribute.clone();
                let Some(data) = data.try_into_mesh_attribute_data(&self.custom_vertex_attributes)
                else {
                    tracing::warn!(
                        "Deserialized mesh contains custom vertex attribute {attribute:?} that \
          was not specified with `MeshDeserializer::add_custom_vertex_attribute`. Ignoring."
                    );
                    return None;
                };
                Some((id, data))
            })
            .collect();
        let extractable_data = MeshExtractableData {
            attributes,
            indices: serialized_mesh.indices,
            primitive_topology: serialized_mesh.primitive_topology,
            #[cfg(feature = "morph")]
            morph_target_names: None,
            #[cfg(feature = "morph")]
            morph_targets: None,
        };
        Mesh {
            extractable_data: Some(extractable_data),
            ..Mesh::new(
                serialized_mesh.primitive_topology,
                RenderAssetUsages::default(),
            )
        }
    }
}

/// Error that can occur when calling [`MeshExtractableData::merge`].
#[derive(Error, Debug, Clone)]
pub enum MeshMergeError {
    #[error("Incompatible vertex attribute types: {} and {}", self_attribute.name, other_attribute.map(|a| a.name).unwrap_or("None"))]
    IncompatibleVertexAttributes {
        self_attribute: MeshVertexAttribute,
        other_attribute: Option<MeshVertexAttribute>,
    },
    #[error(
        "Incompatible primitive topologies: {:?} and {:?}",
        self_primitive_topology,
        other_primitive_topology
    )]
    IncompatiblePrimitiveTopology {
        self_primitive_topology: PrimitiveTopology,
        other_primitive_topology: PrimitiveTopology,
    },
    #[error("Mesh access error: {0}")]
    MeshAccessError(#[from] ExtractableAssetAccessError),
}

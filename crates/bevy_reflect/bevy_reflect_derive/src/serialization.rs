use crate::derive_data::StructField;
use crate::field_attributes::ReflectIgnoreBehavior;
use proc_macro2::Ident;
use quote::quote;
use std::collections::HashMap;
use syn::spanned::Spanned;
use syn::Path;

type ReflectionIndex = usize;

/// Collected serialization data used to generate a `SerializationData` type.
pub(crate) struct SerializationDataDef {
    /// Maps a field's _reflection_ index to its [`SkippedFieldDef`] if marked as `#[reflect(skip_serializing)]`.
    skipped: HashMap<ReflectionIndex, SkippedFieldDef>,
}

impl SerializationDataDef {
    /// Attempts to create a new `SerializationDataDef` from the given collection of fields.
    ///
    /// Returns `Ok(Some(data))` if there are any fields needing to be skipped during serialization.
    /// Otherwise, returns `Ok(None)`.
    pub fn new(fields: &[StructField<'_>]) -> Result<Option<Self>, syn::Error> {
        let mut skipped = HashMap::default();

        for field in fields {
            match field.attrs.ignore {
                ReflectIgnoreBehavior::IgnoreSerialization => {
                    skipped.insert(
                        field.reflection_index.ok_or_else(|| {
                            syn::Error::new(
                                field.data.span(),
                                "internal error: field is missing a reflection index",
                            )
                        })?,
                        SkippedFieldDef::new(field)?,
                    );
                }
                _ => continue,
            }
        }

        if skipped.is_empty() {
            Ok(None)
        } else {
            Ok(Some(Self { skipped }))
        }
    }

    /// Returns a `TokenStream` containing an initialized `SerializationData` type.
    pub fn as_serialization_data(&self, bevy_reflect_path: &Path) -> proc_macro2::TokenStream {
        let fields = self.skipped.iter().map(|(reflection_index, data)| {
            let SkippedFieldDef {
                associated_default_fn: default_fn,
            } = data;
            quote! {(
                #reflection_index,
                #bevy_reflect_path::serde::SkippedField::new(#default_fn)
            )}
        });
        quote! {
            #bevy_reflect_path::serde::SerializationData::new(
                ::core::iter::IntoIterator::into_iter([#(#fields),*])
            )
        }
    }
}

/// Collected field data used to generate a `SkippedField` type.
pub(crate) struct SkippedFieldDef {
    /// The identifier of the [default function] generated by [`AssociatedData`].
    ///
    /// [default function]: crate::associated_data::AssociatedData::default_fn
    /// [`AssociatedData`]: crate::associated_data::AssociatedData
    associated_default_fn: Ident,
}

impl SkippedFieldDef {
    pub fn new(field: &StructField<'_>) -> Result<Self, syn::Error> {
        let associated_default_fn = field
            .associated_data
            .default_fn()
            .ok_or_else(|| {
                syn::Error::new(
                    field.data.span(),
                    "internal error: field is missing an associated default function",
                )
            })?
            .sig
            .ident
            .clone();

        Ok(Self {
            associated_default_fn,
        })
    }
}

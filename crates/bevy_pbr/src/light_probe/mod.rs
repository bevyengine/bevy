//! Light probes for baked global illumination.

use bevy_app::{App, Plugin};
use bevy_asset::{load_internal_asset, AssetId};
use bevy_core_pipeline::core_3d::Camera3d;
use bevy_derive::{Deref, DerefMut};
use bevy_ecs::{
    component::Component,
    entity::Entity,
    query::With,
    reflect::ReflectComponent,
    schedule::IntoSystemConfigs,
    system::{Commands, Local, Query, Res, ResMut, Resource},
};
use bevy_math::{Affine3A, Mat4, Vec3A, Vec4};
use bevy_reflect::{std_traits::ReflectDefault, Reflect};
use bevy_render::{
    extract_instances::ExtractInstancesPlugin,
    primitives::{Aabb, Frustum},
    render_asset::RenderAssets,
    render_resource::{DynamicUniformBuffer, Sampler, Shader, ShaderType, TextureView},
    renderer::{RenderDevice, RenderQueue},
    texture::{FallbackImage, Image},
    Extract, ExtractSchedule, Render, RenderApp, RenderSet,
};
use bevy_transform::prelude::GlobalTransform;
use bevy_utils::{tracing::error, EntityHashMap, FloatOrd, HashMap};

use std::hash::Hash;
use std::ops::Deref;

use crate::{
    irradiance_volume::IRRADIANCE_VOLUME_SHADER_HANDLE,
    light_probe::environment_map::{
        binding_arrays_are_usable, EnvironmentMapIds, EnvironmentMapLight,
        ENVIRONMENT_MAP_SHADER_HANDLE,
    },
};

use self::irradiance_volume::IrradianceVolume;

pub mod environment_map;
pub mod irradiance_volume;

/// The maximum number of reflection probes that each view will consider.
///
/// Because the fragment shader does a linear search through the list for each
/// fragment, this number needs to be relatively small.
pub const MAX_VIEW_LIGHT_PROBES: usize = 8;

/// Adds support for light probes: cuboid bounding regions that apply global
/// illumination to objects within them.
///
/// This also adds support for view environment maps: diffuse and specular
/// cubemaps applied to all objects that a view renders.
pub struct LightProbePlugin;

/// A marker component for a light probe, which is a cuboid region that provides
/// global illumination to all fragments inside it.
///
/// The light probe range is conceptually a unit cube (1×1×1) centered on the
/// origin.  The [`bevy_transform::prelude::Transform`] applied to this entity
/// can scale, rotate, or translate that cube so that it contains all fragments
/// that should take this light probe into account.
///
/// Note that a light probe will have no effect unless the entity contains some
/// kind of illumination. At present, the only supported type of illumination is
/// the [`EnvironmentMapLight`].
#[derive(Component, Debug, Clone, Copy, Default, Reflect)]
#[reflect(Component, Default)]
pub struct LightProbe;

/// A GPU type that stores information about a reflection probe.
#[derive(Clone, Copy, ShaderType, Default)]
struct RenderLightProbe {
    /// The transform from the world space to the model space. This is used to
    /// efficiently check for bounding box intersection.
    inverse_transpose_transform: [Vec4; 3],

    /// The index of the environment map in the diffuse and specular cubemap
    /// binding arrays.
    cubemap_index: i32,

    /// Scale factor applied to the diffuse and specular light generated by this
    /// reflection probe.
    ///
    /// See the comment in [`EnvironmentMapLight`] for details.
    intensity: f32,
}

/// A per-view shader uniform that specifies all the light probes that the view
/// takes into account.
#[derive(ShaderType)]
pub struct LightProbesUniform {
    /// The list of applicable reflection probes, sorted from nearest to the
    /// camera to the farthest away from the camera.
    reflection_probes: [RenderLightProbe; MAX_VIEW_LIGHT_PROBES],

    irradiance_volumes: [RenderLightProbe; MAX_VIEW_LIGHT_PROBES],

    /// The number of reflection probes in the list.
    reflection_probe_count: i32,

    irradiance_volume_count: i32,

    /// The index of the diffuse and specular environment maps associated with
    /// the view itself. This is used as a fallback if no reflection probe in
    /// the list contains the fragment.
    view_cubemap_index: i32,

    /// The smallest valid mipmap level for the specular environment cubemap
    /// associated with the view.
    smallest_specular_mip_level_for_view: u32,

    /// The intensity of the environment cubemap associated with the view.
    ///
    /// See the comment in [`EnvironmentMapLight`] for details.
    intensity_for_view: f32,
}

/// A map from each camera to the light probe uniform associated with it.
#[derive(Resource, Default, Deref, DerefMut)]
struct RenderLightProbes(EntityHashMap<Entity, LightProbesUniform>);

/// A GPU buffer that stores information about all light probes.
#[derive(Resource, Default, Deref, DerefMut)]
pub struct LightProbesBuffer(DynamicUniformBuffer<LightProbesUniform>);

/// A component attached to each camera in the render world that stores the
/// index of the [`LightProbesUniform`] in the [`LightProbesBuffer`].
#[derive(Component, Default, Deref, DerefMut)]
pub struct ViewLightProbesUniformOffset(u32);

/// Information that [`gather_light_probes`] keeps about each light probe.
#[allow(dead_code)]
struct LightProbeInfo<C>
where
    C: LightProbeComponent,
{
    // The transform from world space to light probe space.
    inverse_transform: Mat4,

    // The transform from light probe space to world space.
    affine_transform: Affine3A,

    // Scale factor applied to the diffuse and specular light generated by this
    // reflection probe.
    //
    // See the comment in [`EnvironmentMapLight`] for details.
    intensity: f32,

    // The diffuse and specular environment maps associated with this light
    // probe.
    id: C::Id,
}

/// A component, part of the render world, that stores the mapping from
/// environment map ID to texture index in the diffuse and specular binding
/// arrays.
///
/// Cubemap textures belonging to environment maps are collected into binding
/// arrays, and the index of each texture is presented to the shader for runtime
/// lookup.
///
/// This component is attached to each view in the render world, because each
/// view may have a different set of cubemaps that it considers and therefore
/// cubemap indices are per-view.
#[derive(Component, Default)]
pub struct RenderViewLightProbes<C>
where
    C: LightProbeComponent,
{
    /// The list of environment maps presented to the shader, in order.
    binding_index_to_cubemap: Vec<C::Id>,

    /// The reverse of `binding_index_to_cubemap`: a map from the environment
    /// map IDs to the index in `binding_index_to_cubemap`.
    cubemap_to_binding_index: HashMap<C::Id, u32>,

    render_light_probes: Vec<RenderLightProbe>,

    view_light_probe_info: C::ViewLightProbeInfo,
}

pub trait LightProbeComponent: Send + Sync + Component + Sized {
    type Id: Send + Sync + Clone + Eq + Hash;
    type ViewLightProbeInfo: Send + Sync + Default;

    fn id(&self, image_assets: &RenderAssets<Image>) -> Option<Self::Id>;
    fn intensity(&self) -> f32;
    fn create_render_view_light_probes(
        view_component: Option<&Self>,
        image_assets: &RenderAssets<Image>,
    ) -> RenderViewLightProbes<Self>;
}

impl LightProbe {
    /// Creates a new light probe component.
    #[inline]
    pub fn new() -> Self {
        Self
    }
}

impl Plugin for LightProbePlugin {
    fn build(&self, app: &mut App) {
        load_internal_asset!(
            app,
            ENVIRONMENT_MAP_SHADER_HANDLE,
            "environment_map.wgsl",
            Shader::from_wgsl
        );
        load_internal_asset!(
            app,
            IRRADIANCE_VOLUME_SHADER_HANDLE,
            "irradiance_volume.wgsl",
            Shader::from_wgsl
        );

        app.register_type::<LightProbe>()
            .register_type::<EnvironmentMapLight>();
    }

    fn finish(&self, app: &mut App) {
        let Ok(render_app) = app.get_sub_app_mut(RenderApp) else {
            return;
        };

        render_app
            .add_plugins(ExtractInstancesPlugin::<EnvironmentMapIds>::new())
            .init_resource::<LightProbesBuffer>()
            .init_resource::<RenderLightProbes>()
            .add_systems(ExtractSchedule, gather_light_probes::<EnvironmentMapLight>)
            .add_systems(ExtractSchedule, gather_light_probes::<IrradianceVolume>)
            .add_systems(
                ExtractSchedule,
                build_light_probes_uniforms
                    .after(gather_light_probes::<EnvironmentMapLight>)
                    .after(gather_light_probes::<IrradianceVolume>),
            )
            .add_systems(
                Render,
                upload_light_probes.in_set(RenderSet::PrepareResources),
            );
    }
}

/// Gathers up all light probes in the scene and assigns them to views,
/// performing frustum culling and distance sorting in the process.
///
/// This populates the [`RenderLightProbes`] resource.
#[allow(clippy::too_many_arguments)]
fn gather_light_probes<C>(
    mut render_light_probes: ResMut<RenderLightProbes>,
    image_assets: Res<RenderAssets<Image>>,
    render_device: Res<RenderDevice>,
    light_probe_query: Extract<Query<(&GlobalTransform, &C), With<LightProbe>>>,
    view_query: Extract<Query<(Entity, &GlobalTransform, &Frustum, Option<&C>), With<Camera3d>>>,
    mut reflection_probes: Local<Vec<LightProbeInfo<C>>>,
    mut view_reflection_probes: Local<Vec<LightProbeInfo<C>>>,
    mut commands: Commands,
) where
    C: LightProbeComponent,
{
    // Create [`LightProbeInfo`] for every light probe in the scene.
    reflection_probes.clear();
    reflection_probes.extend(
        light_probe_query
            .iter()
            .filter_map(|query_row| LightProbeInfo::new(query_row, &image_assets)),
    );

    // Build up the light probes uniform and the key table.
    render_light_probes.clear();
    for (view_entity, view_transform, view_frustum, view_component) in view_query.iter() {
        // Cull light probes outside the view frustum.
        view_reflection_probes.clear();
        view_reflection_probes.extend(
            reflection_probes
                .iter()
                .filter(|light_probe_info| light_probe_info.frustum_cull(view_frustum))
                .cloned(),
        );

        // Sort by distance to camera.
        view_reflection_probes.sort_by_cached_key(|light_probe_info| {
            light_probe_info.camera_distance_sort_key(view_transform)
        });

        // Create the light probes list.
        let mut render_view_light_probes =
            C::create_render_view_light_probes(view_component, &image_assets);

        maybe_gather_light_probes(
            &mut render_view_light_probes,
            &view_reflection_probes,
            &render_device,
        );

        // Record the per-view light probes.
        commands
            .get_or_spawn(view_entity)
            .insert(render_view_light_probes);
    }
}

fn build_light_probes_uniforms(
    mut render_light_probes: ResMut<RenderLightProbes>,
    view_query: Extract<Query<Entity, With<Camera3d>>>,
    mut view_light_probes_query: Query<(
        &RenderViewLightProbes<EnvironmentMapLight>,
        &RenderViewLightProbes<IrradianceVolume>,
    )>,
) {
    for view_entity in view_query.iter() {
        let Ok((render_view_environment_maps, render_view_irradiance_volumes)) =
            view_light_probes_query.get_mut(view_entity)
        else {
            error!("Failed to find `RenderViewLightProbes` for the view!");
            continue;
        };

        // Initialize the uniform.
        let mut light_probes_uniform = LightProbesUniform {
            reflection_probes: [RenderLightProbe::default(); MAX_VIEW_LIGHT_PROBES],
            irradiance_volumes: [RenderLightProbe::default(); MAX_VIEW_LIGHT_PROBES],
            reflection_probe_count: render_view_environment_maps
                .len()
                .min(MAX_VIEW_LIGHT_PROBES) as i32,
            irradiance_volume_count: render_view_irradiance_volumes
                .len()
                .min(MAX_VIEW_LIGHT_PROBES) as i32,
            view_cubemap_index: render_view_environment_maps
                .view_light_probe_info
                .cubemap_index,
            smallest_specular_mip_level_for_view: render_view_environment_maps
                .view_light_probe_info
                .smallest_specular_mip_level,
            intensity_for_view: render_view_environment_maps.view_light_probe_info.intensity,
        };

        render_view_environment_maps.add_to_uniform(
            &mut light_probes_uniform.reflection_probes,
            &mut light_probes_uniform.reflection_probe_count,
        );
        render_view_irradiance_volumes.add_to_uniform(
            &mut light_probes_uniform.irradiance_volumes,
            &mut light_probes_uniform.irradiance_volume_count,
        );

        render_light_probes.insert(view_entity, light_probes_uniform);
    }
}

/// Uploads the result of [`gather_light_probes`] to the GPU.
fn upload_light_probes(
    mut commands: Commands,
    light_probes_uniforms: Res<RenderLightProbes>,
    mut light_probes_buffer: ResMut<LightProbesBuffer>,
    render_device: Res<RenderDevice>,
    render_queue: Res<RenderQueue>,
) {
    // Get the uniform buffer writer.
    let Some(mut writer) =
        light_probes_buffer.get_writer(light_probes_uniforms.len(), &render_device, &render_queue)
    else {
        return;
    };

    // Send each view's uniforms to the GPU.
    for (&view_entity, light_probes_uniform) in light_probes_uniforms.iter() {
        commands
            .entity(view_entity)
            .insert(ViewLightProbesUniformOffset(
                writer.write(light_probes_uniform),
            ));
    }
}

impl Default for LightProbesUniform {
    fn default() -> Self {
        Self {
            reflection_probes: [RenderLightProbe::default(); MAX_VIEW_LIGHT_PROBES],
            irradiance_volumes: [RenderLightProbe::default(); MAX_VIEW_LIGHT_PROBES],
            reflection_probe_count: 0,
            irradiance_volume_count: 0,
            view_cubemap_index: -1,
            smallest_specular_mip_level_for_view: 0,
            intensity_for_view: 1.0,
        }
    }
}

/// Gathers up all reflection probes in the scene and writes them into this
/// uniform and `render_view_environment_maps`.
fn maybe_gather_light_probes<C>(
    render_view_light_probes: &mut RenderViewLightProbes<C>,
    light_probes: &[LightProbeInfo<C>],
    render_device: &RenderDevice,
) where
    C: LightProbeComponent,
{
    if !binding_arrays_are_usable(render_device) {
        return;
    }

    for light_probe in light_probes.iter().take(MAX_VIEW_LIGHT_PROBES) {
        // Determine the index of the cubemap in the binding array.
        let cubemap_index = render_view_light_probes.get_or_insert_cubemap(&light_probe.id);

        // Transpose the inverse transform to compress the structure on the
        // GPU (from 4 `Vec4`s to 3 `Vec4`s). The shader will transpose it
        // to recover the original inverse transform.
        let inverse_transpose_transform = light_probe.inverse_transform.transpose();

        // Write in the reflection probe data.
        render_view_light_probes
            .render_light_probes
            .push(RenderLightProbe {
                inverse_transpose_transform: [
                    inverse_transpose_transform.x_axis,
                    inverse_transpose_transform.y_axis,
                    inverse_transpose_transform.z_axis,
                ],
                cubemap_index: cubemap_index as i32,
                intensity: light_probe.intensity,
            });
    }
}

impl<C> LightProbeInfo<C>
where
    C: LightProbeComponent,
{
    /// Given the set of light probe components, constructs and returns
    /// [`LightProbeInfo`]. This is done for every light probe in the scene
    /// every frame.
    fn new(
        (light_probe_transform, environment_map): (&GlobalTransform, &C),
        image_assets: &RenderAssets<Image>,
    ) -> Option<LightProbeInfo<C>> {
        environment_map.id(image_assets).map(|id| LightProbeInfo {
            affine_transform: light_probe_transform.affine(),
            inverse_transform: light_probe_transform.compute_matrix().inverse(),
            id,
            intensity: environment_map.intensity(),
        })
    }

    /// Returns true if this light probe is in the viewing frustum of the camera
    /// or false if it isn't.
    fn frustum_cull(&self, view_frustum: &Frustum) -> bool {
        view_frustum.intersects_obb(
            &Aabb {
                center: Vec3A::default(),
                half_extents: Vec3A::splat(0.5),
            },
            &self.affine_transform,
            true,
            false,
        )
    }

    /// Returns the squared distance from this light probe to the camera,
    /// suitable for distance sorting.
    fn camera_distance_sort_key(&self, view_transform: &GlobalTransform) -> FloatOrd {
        FloatOrd(
            (self.affine_transform.translation - view_transform.translation_vec3a())
                .length_squared(),
        )
    }
}

impl<C> RenderViewLightProbes<C>
where
    C: LightProbeComponent,
{
    fn new() -> RenderViewLightProbes<C> {
        RenderViewLightProbes {
            binding_index_to_cubemap: vec![],
            cubemap_to_binding_index: HashMap::new(),
            render_light_probes: vec![],
            view_light_probe_info: C::ViewLightProbeInfo::default(),
        }
    }

    pub(crate) fn len(&self) -> usize {
        self.binding_index_to_cubemap.len()
    }

    /// Adds a cubemap to the list of bindings, if it wasn't there already, and
    /// returns its index within that list.
    pub(crate) fn get_or_insert_cubemap(&mut self, cubemap_id: &C::Id) -> u32 {
        *self
            .cubemap_to_binding_index
            .entry((*cubemap_id).clone())
            .or_insert_with(|| {
                let index = self.binding_index_to_cubemap.len() as u32;
                self.binding_index_to_cubemap.push((*cubemap_id).clone());
                index
            })
    }

    fn add_to_uniform(
        &self,
        render_light_probes: &mut [RenderLightProbe; MAX_VIEW_LIGHT_PROBES],
        render_light_probe_count: &mut i32,
    ) {
        render_light_probes[0..self.render_light_probes.len()]
            .copy_from_slice(&self.render_light_probes[..]);
        *render_light_probe_count = self.render_light_probes.len() as i32;
    }
}

impl<C> Clone for LightProbeInfo<C>
where
    C: LightProbeComponent,
{
    fn clone(&self) -> Self {
        Self {
            inverse_transform: self.inverse_transform.clone(),
            affine_transform: self.affine_transform.clone(),
            intensity: self.intensity.clone(),
            id: self.id.clone(),
        }
    }
}

/// Adds a diffuse or specular texture view to the `texture_views` list, and
/// populates `sampler` if this is the first such view.
pub(crate) fn add_texture_view<'a>(
    texture_views: &mut Vec<&'a <TextureView as Deref>::Target>,
    sampler: &mut Option<&'a Sampler>,
    image_id: AssetId<Image>,
    images: &'a RenderAssets<Image>,
    fallback_image: &'a FallbackImage,
) {
    match images.get(image_id) {
        None => {
            // Use the fallback image if the cubemap isn't loaded yet.
            texture_views.push(&*fallback_image.cube.texture_view);
        }
        Some(image) => {
            // If this is the first texture view, populate `sampler`.
            if sampler.is_none() {
                *sampler = Some(&image.sampler);
            }

            texture_views.push(&*image.texture_view);
        }
    }
}

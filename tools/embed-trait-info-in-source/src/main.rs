use std::{
    collections::{HashMap, HashSet},
    fs::{read_to_string, File},
    path::{Path, PathBuf},
    process::Command,
    sync::LazyLock,
};

use rustdoc_types::{Crate, Id, ItemEnum, Module, Span};

/// Embedding metadata needed for trait tags in item listings by modifying the source files.
/// Trait tags on the doc pages of individual items are based on scanning the DOM instead, as embedding metadata doesn't work if the item is generated by a macro.
pub fn main() {
    // Runnable from everywhere
    let tool_dir = PathBuf::from(
        std::env::var("CARGO_MANIFEST_DIR")
            .expect("Please run via cargo or set CARGO_MANIFEST_DIR"),
    );
    let root_dir = tool_dir.join("../..").canonicalize().unwrap();

    // Generate documentation as json
    Command::new("cargo")
        .args(["doc", "--all-features", "--workspace", "--no-deps"])
        .env("RUSTDOCFLAGS", "-Z unstable-options --output-format json")
        .current_dir(&root_dir)
        .status()
        .expect("Failed to run cargo doc in {root_dir:?}");

    for package in packages_in_workspace() {
        try_embed_info_in_package_source(&root_dir, &package);
    }
}

fn packages_in_workspace() -> Vec<String> {
    let output = Command::new("cargo")
        .args(["metadata", "--no-deps"])
        .output()
        .unwrap();
    assert!(output.status.success());

    let metadata = serde_json::from_slice::<serde_json::Value>(&output.stdout).unwrap();
    assert_eq!(metadata.get("version").unwrap().as_i64().unwrap(), 1);

    metadata
        .get("packages")
        .unwrap()
        .as_array()
        .unwrap()
        .iter()
        .map(|package| package.get("name").unwrap().as_str().unwrap().to_owned())
        .collect()
}

fn try_embed_info_in_package_source(root_dir: &Path, package: &str) {
    let root_dir = PathBuf::from(root_dir);
    let crate_doc: Crate = {
        let file_name = root_dir.join(format!("target/doc/{package}.json"));
        let Ok(file) = File::open(&file_name) else {
            // Not all packages will get their documentation built and published
            return;
        };
        serde_json::from_reader(file).unwrap()
    };

    // A file may contain multiple modules
    let mut by_file = HashMap::<PathBuf, Vec<_>>::new();
    for (module_span, info) in info_for_modules(&crate_doc) {
        by_file
            .entry(module_span.filename.clone())
            .or_default()
            .push((module_span, info));
    }

    for (file, modules) in by_file {
        let source_file = root_dir.join(file);
        let mut src = read_to_string(&source_file).unwrap();

        let mut modules = modules
            .into_iter()
            .map(|(module_span, info)| (position_in_string(&src, module_span.begin), info))
            .collect::<Vec<_>>();

        // Sort them so the index into src doesn't get messed up
        modules.sort_by_key(|(pos, _)| *pos);

        for (pos, info) in modules.into_iter().rev() {
            // File-based modules will need inner attributes,
            // modules with a body can get an out one.
            let attr_syntax = if pos == 0 { "#!" } else { "#" };
            // Insert data about implemented traits as a doc comment.
            // The id lets the ECMAScript find the data.
            // The `config_attr` stops it from showing up in rust-analyzer and the css from in the webpage.
            let json = serde_json::to_string(&info).unwrap();
            let escaped = json.replace('"', "\\\"");
            src.insert_str(pos, &format!(
                r#"{attr_syntax}[cfg_attr(any(docsrs_dep, docsrs), doc = "<div id=\"bevy-traits-data\" style=\"display:none\">{escaped}</div>")]
"#,
            ));
        }

        std::fs::write(source_file, src).unwrap();
    }
}

/// Find the byte index into the string.
/// Line is 1-based, column is 0-based.
fn position_in_string(str: &str, (line, column): (usize, usize)) -> usize {
    let mut pos = 0;
    // Line endings can be two bytes (CR+LF) on Windows
    for _ in 1..line {
        pos += str[pos..].find('\n').unwrap() + 1;
    }
    pos + column
}

type BevyTraits<'a> = Vec<&'a str>;
type ModuleInfo<'a> = HashMap<&'a str, BevyTraits<'a>>;

// Finds all metadata within the crate we need to embed.
fn info_for_modules(crate_doc: &Crate) -> Vec<(&Span, ModuleInfo)> {
    let mut modules = Vec::new();
    for item in crate_doc.index.values() {
        let ItemEnum::Module(module) = &item.inner else {
            continue;
        };
        // We can only insert the metadata if we know where to
        let Some(mod_span) = &item.span else { continue };
        let info = info_for_module(crate_doc, module);
        if !info.is_empty() {
            modules.push((mod_span, info));
        }
    }
    modules
}

fn info_for_module<'a>(crate_doc: &'a Crate, module: &'a Module) -> ModuleInfo<'a> {
    module
        .items
        .iter()
        .flat_map(|&id| name_and_bevy_traits_for_item(crate_doc, id))
        .collect()
}

/// If the item implements traits we're interested in,
/// return the name and those traits.
/// This can return multiple (item name, traits) pairs if
/// the item is actually a wildcard import.
fn name_and_bevy_traits_for_item(crate_doc: &'_ Crate, item_id: Id) -> ModuleInfo<'_> {
    let Some(item) = &crate_doc.index.get(&item_id) else {
        // Macro imports can't be found
        return Default::default();
    };
    let (name, impls) = match &item.inner {
        ItemEnum::Struct(def) => (item.name.as_ref(), &def.impls),
        ItemEnum::Enum(def) => (item.name.as_ref(), &def.impls),
        ItemEnum::Union(def) => (item.name.as_ref(), &def.impls),
        ItemEnum::Use(use_item) => {
            let Some(used_id) = use_item.id else {
                // Reexport of a primitive
                return Default::default();
            };
            if use_item.is_glob {
                // Reexport of all items in the use-d module
                let Some(used_item) = &crate_doc.index.get(&used_id) else {
                    // Macro imports can't be found
                    return Default::default();
                };
                let ItemEnum::Module(module) = &used_item.inner else {
                    panic!();
                };
                return info_for_module(crate_doc, module);
            } else {
                return name_and_bevy_traits_for_item(crate_doc, used_id);
            }
        }
        _ => return Default::default(),
    };

    let name = name.unwrap();
    let mut traits = Vec::new();
    for impl_id in impls {
        let ItemEnum::Impl(impl_block) = &crate_doc.index[impl_id].inner else {
            panic!()
        };
        if let Some(trait_) = &impl_block.trait_ {
            let trait_name = trait_.path.as_str();
            // This matches how EMCAScript detects traits
            if BEVY_TRAITS.contains(trait_name) {
                traits.push(trait_name);
            }
        }
    }

    if traits.is_empty() {
        Default::default()
    } else {
        [(name.as_str(), traits)].into_iter().collect()
    }
}

static BEVY_TRAITS: LazyLock<HashSet<String>> = LazyLock::new(|| {
    [
        "Plugin",
        "PluginGroup",
        "Component",
        "Resource",
        "Asset",
        "Event",
        "ScheduleLabel",
        "SystemSet",
        "SystemParam",
    ]
    .iter()
    .map(|s| s.to_string())
    .collect()
});

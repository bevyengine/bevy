# **bevy_earthworks PRD**

## Voxel Terrain & Construction Simulation Plugin for Bevy

**Version:** 1.0
**Last Updated:** January 2025
**Repository:** `github.com/reuben/bevy_earthworks` (fork of `bevyengine/bevy`)

---

## Table of Contents

1. [Executive Summary](#1-executive-summary)
2. [Project Context](#2-project-context)
3. [Goals & Non-Goals](#3-goals--non-goals)
4. [Technical Architecture](#4-technical-architecture)
5. [Core Systems](#5-core-systems)
6. [Component Specifications](#6-component-specifications)
7. [Plan Execution System](#7-plan-execution-system)
8. [Rendering Pipeline](#8-rendering-pipeline)
9. [User Interface](#9-user-interface)
10. [Asset Pipeline](#10-asset-pipeline)
11. [Performance Requirements](#11-performance-requirements)
12. [Testing Strategy](#12-testing-strategy)
13. [Implementation Roadmap](#13-implementation-roadmap)
14. [Success Criteria](#14-success-criteria)
15. [Appendices](#15-appendices)

---

## 1. Executive Summary

### 1.1 What

`bevy_earthworks` is a Bevy plugin providing:
- Volumetric voxel terrain with efficient modification and rendering
- Construction machine simulation with work envelope constraints
- Plan execution and playback system for pre-computed operations
- Timeline UI for interactive visualization

### 1.2 Why

**Primary:** Serve as the visualization layer for TerraFirma, rendering optimized earthworks plans generated by Julia.

**Secondary:** Provide a reusable, general-purpose terrain manipulation system for the Bevy ecosystem (mining games, construction sims, farming games).

**Tertiary:** Satisfy the Brownfield Challenge requirement—fork a substantial open-source repo and build a non-trivial extension.

### 1.3 Key Decisions

| Decision | Choice | Rationale |
|----------|--------|-----------|
| Plugin vs. Fork modification | Plugin crate within fork | Clean separation, publishable to crates.io |
| Terrain representation | Chunked voxel grid | Industry standard, good LOD support |
| Mesh generation | Greedy meshing | Best balance of quality and performance |
| Plan source | External JSON | Julia handles optimization; Bevy just visualizes |
| Validation | Trust the plan | Julia validates exhaustively; no round-trip needed |

---

## 2. Project Context

### 2.1 Brownfield Challenge Alignment

| Requirement | How This Project Satisfies |
|-------------|---------------------------|
| Fork substantial repo (1000+ stars) | Bevy: 37k+ stars, 3k+ forks |
| New language/ecosystem | Rust + Bevy ECS (new to developer) |
| Understand existing architecture | Must integrate with Bevy's ECS, rendering, asset systems |
| Non-trivial feature | Complete voxel engine + simulation + UI |
| Production-ready | Documented API, examples, tests |
| 1-2 week equivalent scope | Matches complexity of team sprint |

### 2.2 TerraFirma Integration

```
┌─────────────────────────────────────────────────────────────────┐
│                        TerraFirma System                         │
└─────────────────────────────────────────────────────────────────┘

┌──────────────────────┐         ┌──────────────────────┐
│   TerraFirma.jl      │         │   bevy_earthworks    │
│   ──────────────     │         │   ───────────────    │
│                      │         │                      │
│  • 0.1 ft precision  │         │  • 1 ft precision    │
│  • Optimization      │  JSON   │  • Visualization     │
│  • Validation        │ ─────▶  │  • Playback          │
│  • Scoring           │  Plan   │  • UI                │
│  • Source of truth   │         │  • Video export      │
│                      │         │                      │
└──────────────────────┘         └──────────────────────┘
```

### 2.3 Target Users

1. **TerraFirma (primary):** Load and visualize optimized excavation plans
2. **Game developers:** Build mining, construction, or farming games
3. **Simulation developers:** Training tools, planning visualizations
4. **Bevy community:** Reference implementation of voxel terrain

---

## 3. Goals & Non-Goals

### 3.1 Goals

| Priority | Goal | Success Metric |
|----------|------|----------------|
| P0 | Load and render voxel terrain from plan JSON | Terrain displays correctly |
| P0 | Execute plan steps with correct terrain modification | Dirt appears/disappears at right times |
| P0 | Playback controls (play, pause, scrub, speed) | User can navigate timeline |
| P1 | Machine visualization with animation | Machines move smoothly between keyframes |
| P1 | Work envelope debug visualization | Toroidal/blade shapes render correctly |
| P1 | Score/stats overlay | Cost, time, volume displayed |
| P2 | Particle effects (dust, debris) | Visual polish for digging/dumping |
| P2 | Video export | Frame capture to image sequence |
| P2 | Camera system (orbit, follow, cinematic) | Good default views |

### 3.2 Non-Goals

| Non-Goal | Rationale |
|----------|-----------|
| Physics simulation | Julia handles this; Bevy just plays back |
| Constraint validation | Plan is pre-validated by Julia |
| Optimization | Out of scope; Julia's responsibility |
| Multiplayer/networking | Future extension, not MVP |
| Procedural terrain generation | Load from plan; generation is Julia's job |
| Audio | Nice-to-have, not required for TerraFirma |

### 3.3 Future Considerations (Post-MVP)

- Real-time terrain editing (for game dev use case)
- LOD system for large terrains
- Streaming/chunking for massive worlds
- Network sync for multiplayer
- Custom shaders (triplanar mapping, moisture)

---

## 4. Technical Architecture

### 4.1 Crate Structure

```
bevy/                              # Forked Bevy repository
├── crates/
│   ├── bevy_earthworks/           # NEW: Our plugin
│   │   ├── Cargo.toml
│   │   ├── src/
│   │   │   ├── lib.rs             # Plugin entry, prelude
│   │   │   ├── terrain/
│   │   │   │   ├── mod.rs
│   │   │   │   ├── voxel.rs       # Voxel data structures
│   │   │   │   ├── chunk.rs       # Chunk management
│   │   │   │   ├── operations.rs  # Excavate, fill, query
│   │   │   │   ├── meshing.rs     # Greedy mesh algorithm
│   │   │   │   └── materials.rs   # Material definitions
│   │   │   ├── machines/
│   │   │   │   ├── mod.rs
│   │   │   │   ├── components.rs  # Machine, Envelope, Mobility
│   │   │   │   ├── catalog.rs     # Preset definitions
│   │   │   │   ├── animation.rs   # State machine, interpolation
│   │   │   │   └── gizmos.rs      # Debug visualization
│   │   │   ├── plan/
│   │   │   │   ├── mod.rs
│   │   │   │   ├── schema.rs      # Plan, Step, Action types
│   │   │   │   ├── loader.rs      # JSON asset loader
│   │   │   │   ├── executor.rs    # Playback system
│   │   │   │   └── timeline.rs    # Keyframe interpolation
│   │   │   ├── scoring/
│   │   │   │   ├── mod.rs
│   │   │   │   └── tracker.rs     # Cost/time accumulation
│   │   │   ├── ui/
│   │   │   │   ├── mod.rs
│   │   │   │   ├── timeline.rs    # Playback controls
│   │   │   │   ├── overlay.rs     # Score display
│   │   │   │   └── inspector.rs   # Machine info panel
│   │   │   ├── camera/
│   │   │   │   ├── mod.rs
│   │   │   │   ├── orbit.rs       # Orbit camera controller
│   │   │   │   └── follow.rs      # Follow active machine
│   │   │   ├── effects/
│   │   │   │   ├── mod.rs
│   │   │   │   └── particles.rs   # Dust, debris effects
│   │   │   └── export/
│   │   │       ├── mod.rs
│   │   │       └── video.rs       # Frame capture
│   │   ├── examples/
│   │   │   ├── terrafirma.rs      # TerraFirma demo
│   │   │   ├── sandbox.rs         # Interactive editing
│   │   │   └── benchmark.rs       # Performance testing
│   │   └── tests/
│   │       ├── terrain_tests.rs
│   │       ├── meshing_tests.rs
│   │       └── plan_tests.rs
│   │
│   ├── bevy_app/                  # Existing Bevy crates
│   ├── bevy_ecs/
│   ├── bevy_render/
│   └── ...
│
└── Cargo.toml                     # Workspace, includes bevy_earthworks
```

### 4.2 Dependency Graph

```
bevy_earthworks
├── bevy_app          (Plugin trait)
├── bevy_ecs          (Components, Systems, Resources)
├── bevy_asset        (Asset loading)
├── bevy_render       (Mesh, Materials)
├── bevy_pbr          (StandardMaterial, lighting)
├── bevy_gizmos       (Debug visualization)
├── bevy_egui         (UI - optional feature)
├── serde             (JSON deserialization)
├── base64            (Terrain data decoding)
└── parking_lot       (Chunk locking for async mesh gen)
```

### 4.3 Plugin Architecture

```rust
// lib.rs

use bevy::prelude::*;

pub mod terrain;
pub mod machines;
pub mod plan;
pub mod scoring;
pub mod ui;
pub mod camera;
pub mod effects;
pub mod export;

pub mod prelude {
    pub use crate::terrain::{VoxelTerrain, TerrainConfig, VoxelState, MaterialId};
    pub use crate::machines::{Machine, WorkEnvelope, MachineKind};
    pub use crate::plan::{ExecutionPlan, PlanStep, PlannedAction, PlanPlayback};
    pub use crate::scoring::SimulationScore;
    pub use crate::EarthworksPlugin;
}

/// Main plugin - add this to your Bevy app
pub struct EarthworksPlugin {
    pub config: EarthworksConfig,
}

#[derive(Clone, Resource)]
pub struct EarthworksConfig {
    /// Terrain settings
    pub terrain: TerrainConfig,
    /// Enable built-in UI (requires bevy_egui feature)
    pub enable_ui: bool,
    /// Enable debug gizmos (work envelopes, chunk bounds)
    pub enable_debug_visuals: bool,
    /// Enable particle effects
    pub enable_effects: bool,
}

impl Default for EarthworksConfig {
    fn default() -> Self {
        Self {
            terrain: TerrainConfig::default(),
            enable_ui: true,
            enable_debug_visuals: false,
            enable_effects: true,
        }
    }
}

impl Plugin for EarthworksPlugin {
    fn build(&self, app: &mut App) {
        // Core resources
        app.insert_resource(self.config.clone())
           .init_resource::<VoxelTerrain>()
           .init_resource::<SimulationScore>()
           .init_resource::<PlanPlayback>();
        
        // Asset loaders
        app.init_asset::<ExecutionPlan>()
           .init_asset_loader::<plan::PlanLoader>();
        
        // Core systems
        app.add_systems(Update, (
            terrain::chunk_dirty_system,
            terrain::mesh_generation_system,
            plan::plan_loader_system,
            plan::plan_executor_system,
            machines::animation_system,
            scoring::score_tracker_system,
        ).chain());
        
        // Events
        app.add_event::<TerrainModifiedEvent>()
           .add_event::<PlanStepEvent>()
           .add_event::<MachineEvent>();
        
        // Optional subsystems
        if self.config.enable_ui {
            app.add_plugins(ui::EarthworksUiPlugin);
        }
        
        if self.config.enable_debug_visuals {
            app.add_systems(Update, machines::gizmos::draw_work_envelopes);
        }
        
        if self.config.enable_effects {
            app.add_plugins(effects::ParticlePlugin);
        }
    }
}

/// Convenience plugin with all features enabled
impl Default for EarthworksPlugin {
    fn default() -> Self {
        Self {
            config: EarthworksConfig::default(),
        }
    }
}
```

---

## 5. Core Systems

### 5.1 System Execution Order

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                            UPDATE SCHEDULE                                   │
└─────────────────────────────────────────────────────────────────────────────┘

┌─────────────────┐
│  Input Systems  │  (Bevy built-in)
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ Camera Control  │  camera::orbit_camera_system
│                 │  camera::follow_camera_system
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ Plan Execution  │  plan::plan_loader_system      (load JSON when ready)
│                 │  plan::plan_executor_system    (advance timeline)
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ Terrain Ops     │  terrain::apply_operations     (excavate/fill from plan)
│                 │  terrain::chunk_dirty_system   (mark modified chunks)
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ Machine Update  │  machines::animation_system    (interpolate positions)
│                 │  machines::state_machine       (update activity)
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ Scoring         │  scoring::score_tracker_system (accumulate stats)
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ Effects         │  effects::particle_system      (spawn/update particles)
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ Mesh Generation │  terrain::mesh_generation_system (async, chunked)
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ UI              │  ui::timeline_system           (egui immediate mode)
│                 │  ui::overlay_system
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ Debug Gizmos    │  machines::gizmos::draw_work_envelopes
│                 │  terrain::gizmos::draw_chunk_bounds
└─────────────────┘
```

### 5.2 Event Flow

```rust
// events.rs

/// Fired when terrain is modified
#[derive(Event)]
pub struct TerrainModifiedEvent {
    pub chunk_pos: IVec3,
    pub operation: TerrainOperation,
    pub volume_changed: f32,  // Cubic meters
}

#[derive(Clone, Debug)]
pub enum TerrainOperation {
    Excavate { material: MaterialId },
    Fill { material: MaterialId },
    Clear,
}

/// Fired when a plan step completes
#[derive(Event)]
pub struct PlanStepEvent {
    pub step_index: usize,
    pub step: PlanStep,
    pub result: StepResult,
}

#[derive(Clone, Debug)]
pub struct StepResult {
    pub duration: f32,
    pub volume_moved: f32,
    pub success: bool,
}

/// Fired for machine state changes
#[derive(Event)]
pub struct MachineEvent {
    pub machine: Entity,
    pub event_type: MachineEventType,
}

#[derive(Clone, Debug)]
pub enum MachineEventType {
    StartedMoving { to: Vec3 },
    ReachedDestination,
    StartedExcavating,
    FinishedExcavating { volume: f32 },
    StartedDumping,
    FinishedDumping { volume: f32 },
    BecameIdle,
}
```

---

## 6. Component Specifications

### 6.1 Terrain Components

```rust
// terrain/voxel.rs

use bevy::prelude::*;

/// Global terrain configuration
#[derive(Clone, Resource)]
pub struct TerrainConfig {
    /// Size of each voxel in meters (default: 0.3048 = 1 ft)
    pub voxel_size: f32,
    /// Voxels per chunk edge (default: 16)
    pub chunk_size: u32,
    /// Maximum chunks to mesh per frame (default: 4)
    pub max_mesh_per_frame: u32,
    /// Enable LOD (default: false for MVP)
    pub enable_lod: bool,
}

impl Default for TerrainConfig {
    fn default() -> Self {
        Self {
            voxel_size: 0.3048,  // 1 foot
            chunk_size: 16,
            max_mesh_per_frame: 4,
            enable_lod: false,
        }
    }
}

/// State of a single voxel
#[derive(Clone, Copy, PartialEq, Eq, Default)]
#[repr(u8)]
pub enum VoxelState {
    #[default]
    Empty = 0,
    Solid = 1,
    Disturbed = 2,  // Loose fill (different visual)
}

/// Material type for voxels
#[derive(Clone, Copy, PartialEq, Eq, Default, Hash)]
#[repr(u8)]
pub enum MaterialId {
    #[default]
    Dirt = 0,
    Clay = 1,
    Rock = 2,
    Topsoil = 3,
    Gravel = 4,
}

impl MaterialId {
    pub fn color(&self) -> Color {
        match self {
            Self::Dirt => Color::srgb(0.55, 0.35, 0.2),
            Self::Clay => Color::srgb(0.7, 0.45, 0.3),
            Self::Rock => Color::srgb(0.5, 0.5, 0.5),
            Self::Topsoil => Color::srgb(0.3, 0.25, 0.15),
            Self::Gravel => Color::srgb(0.6, 0.55, 0.5),
        }
    }
}

/// Packed voxel data (2 bytes per voxel)
#[derive(Clone, Copy, Default)]
#[repr(C)]
pub struct Voxel {
    pub state: VoxelState,
    pub material: MaterialId,
}

impl Voxel {
    pub const EMPTY: Self = Self {
        state: VoxelState::Empty,
        material: MaterialId::Dirt,
    };
    
    pub const fn solid(material: MaterialId) -> Self {
        Self {
            state: VoxelState::Solid,
            material,
        }
    }
    
    pub fn is_solid(&self) -> bool {
        self.state != VoxelState::Empty
    }
}
```

```rust
// terrain/chunk.rs

use super::*;
use bevy::prelude::*;
use parking_lot::RwLock;
use std::sync::Arc;

/// A 3D chunk of voxels
pub struct Chunk {
    /// Position in chunk coordinates (not world)
    pub position: IVec3,
    /// Voxel data (CHUNK_SIZE³ voxels)
    pub voxels: Box<[[[Voxel; 16]; 16]; 16]>,  // Stack-friendly fixed size
    /// Whether mesh needs regeneration
    pub dirty: bool,
    /// Current mesh handle (if any)
    pub mesh: Option<Handle<Mesh>>,
    /// LOD level (0 = full detail)
    pub lod: u8,
}

impl Chunk {
    pub fn new(position: IVec3) -> Self {
        Self {
            position,
            voxels: Box::new([[[Voxel::EMPTY; 16]; 16]; 16]),
            dirty: true,
            mesh: None,
            lod: 0,
        }
    }
    
    pub fn new_filled(position: IVec3, voxel: Voxel) -> Self {
        Self {
            position,
            voxels: Box::new([[[voxel; 16]; 16]; 16]),
            dirty: true,
            mesh: None,
            lod: 0,
        }
    }
    
    #[inline]
    pub fn get(&self, local: UVec3) -> Voxel {
        self.voxels[local.x as usize][local.y as usize][local.z as usize]
    }
    
    #[inline]
    pub fn set(&mut self, local: UVec3, voxel: Voxel) {
        self.voxels[local.x as usize][local.y as usize][local.z as usize] = voxel;
        self.dirty = true;
    }
    
    /// Check if chunk is entirely empty (optimization)
    pub fn is_empty(&self) -> bool {
        self.voxels.iter().all(|plane| {
            plane.iter().all(|row| {
                row.iter().all(|v| !v.is_solid())
            })
        })
    }
    
    /// Check if chunk is entirely solid (optimization)
    pub fn is_full(&self) -> bool {
        self.voxels.iter().all(|plane| {
            plane.iter().all(|row| {
                row.iter().all(|v| v.is_solid())
            })
        })
    }
}
```

```rust
// terrain/mod.rs (VoxelTerrain resource)

use super::*;
use bevy::prelude::*;
use std::collections::HashMap;

/// Main terrain resource
#[derive(Resource)]
pub struct VoxelTerrain {
    /// Configuration
    pub config: TerrainConfig,
    /// Chunk storage
    chunks: HashMap<IVec3, Chunk>,
    /// World-space bounds (for fast rejection)
    pub bounds: Option<Aabb>,
    /// Total solid voxels (for stats)
    pub solid_count: u64,
}

impl Default for VoxelTerrain {
    fn default() -> Self {
        Self {
            config: TerrainConfig::default(),
            chunks: HashMap::new(),
            bounds: None,
            solid_count: 0,
        }
    }
}

impl VoxelTerrain {
    /// Initialize terrain from plan's initial state
    pub fn initialize_from_plan(&mut self, plan: &ExecutionPlan) {
        let site = &plan.site;
        
        // Decode terrain data
        let terrain_data = decode_terrain(&site.initial_terrain);
        
        // Calculate chunk coverage
        let chunk_size = self.config.chunk_size as i32;
        let min_chunk = self.world_to_chunk(site.bounds.min);
        let max_chunk = self.world_to_chunk(site.bounds.max);
        
        // Create chunks and fill with data
        for cx in min_chunk.x..=max_chunk.x {
            for cy in min_chunk.y..=max_chunk.y {
                for cz in min_chunk.z..=max_chunk.z {
                    let chunk_pos = IVec3::new(cx, cy, cz);
                    let mut chunk = Chunk::new(chunk_pos);
                    
                    // Fill from terrain data
                    self.fill_chunk_from_data(&mut chunk, &terrain_data, &site);
                    
                    if !chunk.is_empty() {
                        self.chunks.insert(chunk_pos, chunk);
                    }
                }
            }
        }
        
        self.bounds = Some(Aabb {
            center: (site.bounds.min + site.bounds.max) / 2.0,
            half_extents: (site.bounds.max - site.bounds.min) / 2.0,
        });
        
        self.recalculate_solid_count();
    }
    
    /// Get voxel at world position
    pub fn get_voxel(&self, world_pos: Vec3) -> Option<Voxel> {
        let (chunk_pos, local) = self.world_to_chunk_local(world_pos);
        self.chunks.get(&chunk_pos).map(|c| c.get(local))
    }
    
    /// Set voxel at world position
    pub fn set_voxel(&mut self, world_pos: Vec3, voxel: Voxel) {
        let (chunk_pos, local) = self.world_to_chunk_local(world_pos);
        
        let chunk = self.chunks
            .entry(chunk_pos)
            .or_insert_with(|| Chunk::new(chunk_pos));
        
        let old = chunk.get(local);
        chunk.set(local, voxel);
        
        // Update solid count
        if old.is_solid() && !voxel.is_solid() {
            self.solid_count = self.solid_count.saturating_sub(1);
        } else if !old.is_solid() && voxel.is_solid() {
            self.solid_count += 1;
        }
    }
    
    /// Excavate a region, returns volume removed in cubic meters
    pub fn excavate(&mut self, shape: &impl Shape) -> f32 {
        let mut removed = 0u64;
        let voxel_volume = self.config.voxel_size.powi(3);
        
        // Get affected chunks
        let bounds = shape.bounding_box();
        let min_chunk = self.world_to_chunk(bounds.min);
        let max_chunk = self.world_to_chunk(bounds.max);
        
        for cx in min_chunk.x..=max_chunk.x {
            for cy in min_chunk.y..=max_chunk.y {
                for cz in min_chunk.z..=max_chunk.z {
                    let chunk_pos = IVec3::new(cx, cy, cz);
                    
                    if let Some(chunk) = self.chunks.get_mut(&chunk_pos) {
                        removed += self.excavate_chunk(chunk, shape);
                    }
                }
            }
        }
        
        self.solid_count = self.solid_count.saturating_sub(removed);
        removed as f32 * voxel_volume
    }
    
    /// Fill a region with material
    pub fn fill(&mut self, center: Vec3, volume_m3: f32, material: MaterialId) -> f32 {
        let voxel_volume = self.config.voxel_size.powi(3);
        let voxels_to_place = (volume_m3 / voxel_volume).ceil() as u32;
        
        // Simple pile model: stack upward from center
        let mut placed = 0u32;
        let mut layer = 0i32;
        let voxel_size = self.config.voxel_size;
        
        while placed < voxels_to_place {
            let radius = (5 - layer).max(1);
            
            for dx in -radius..=radius {
                for dz in -radius..=radius {
                    let pos = center + Vec3::new(
                        dx as f32 * voxel_size,
                        layer as f32 * voxel_size,
                        dz as f32 * voxel_size,
                    );
                    
                    if self.get_voxel(pos).map(|v| !v.is_solid()).unwrap_or(true) {
                        self.set_voxel(pos, Voxel {
                            state: VoxelState::Disturbed,
                            material,
                        });
                        placed += 1;
                        
                        if placed >= voxels_to_place {
                            break;
                        }
                    }
                }
                if placed >= voxels_to_place {
                    break;
                }
            }
            
            layer += 1;
            if layer > 50 {
                break;  // Safety limit
            }
        }
        
        placed as f32 * voxel_volume
    }
    
    /// Get all dirty chunks that need remeshing
    pub fn dirty_chunks(&self) -> impl Iterator<Item = IVec3> + '_ {
        self.chunks.iter()
            .filter(|(_, c)| c.dirty)
            .map(|(pos, _)| *pos)
    }
    
    /// Mark chunk as clean after meshing
    pub fn mark_clean(&mut self, chunk_pos: IVec3) {
        if let Some(chunk) = self.chunks.get_mut(&chunk_pos) {
            chunk.dirty = false;
        }
    }
    
    /// Set mesh handle for chunk
    pub fn set_chunk_mesh(&mut self, chunk_pos: IVec3, mesh: Handle<Mesh>) {
        if let Some(chunk) = self.chunks.get_mut(&chunk_pos) {
            chunk.mesh = Some(mesh);
        }
    }
    
    // Coordinate conversion helpers
    
    fn world_to_chunk(&self, world: Vec3) -> IVec3 {
        let chunk_world_size = self.config.chunk_size as f32 * self.config.voxel_size;
        IVec3::new(
            (world.x / chunk_world_size).floor() as i32,
            (world.y / chunk_world_size).floor() as i32,
            (world.z / chunk_world_size).floor() as i32,
        )
    }
    
    fn world_to_chunk_local(&self, world: Vec3) -> (IVec3, UVec3) {
        let chunk_pos = self.world_to_chunk(world);
        let chunk_world_size = self.config.chunk_size as f32 * self.config.voxel_size;
        let chunk_origin = chunk_pos.as_vec3() * chunk_world_size;
        let local_world = world - chunk_origin;
        let local = UVec3::new(
            (local_world.x / self.config.voxel_size).floor() as u32,
            (local_world.y / self.config.voxel_size).floor() as u32,
            (local_world.z / self.config.voxel_size).floor() as u32,
        ).min(UVec3::splat(self.config.chunk_size - 1));
        
        (chunk_pos, local)
    }
    
    fn chunk_to_world(&self, chunk_pos: IVec3) -> Vec3 {
        let chunk_world_size = self.config.chunk_size as f32 * self.config.voxel_size;
        chunk_pos.as_vec3() * chunk_world_size
    }
}
```

### 6.2 Machine Components

```rust
// machines/components.rs

use bevy::prelude::*;

/// Machine identifier
#[derive(Component, Clone, PartialEq, Eq, Hash, Debug)]
pub struct MachineId(pub String);

/// Type of machine
#[derive(Component, Clone, Copy, PartialEq, Eq, Debug)]
pub enum MachineKind {
    Excavator,
    Dozer,
    Loader,
}

/// Current activity state
#[derive(Component, Clone, Debug)]
pub enum MachineActivity {
    Idle,
    Traveling {
        from: Vec3,
        to: Vec3,
        progress: f32,      // 0.0 - 1.0
        path: Option<Vec<Vec3>>,
    },
    Excavating {
        target: Aabb,
        progress: f32,
        expected_yield: f32,
    },
    Dumping {
        target: Vec3,
        progress: f32,
        volume: f32,
    },
    Pushing {
        direction: Vec3,
        distance: f32,
        progress: f32,
    },
}

impl Default for MachineActivity {
    fn default() -> Self {
        Self::Idle
    }
}

/// Work envelope shape
#[derive(Component, Clone, Debug)]
pub enum WorkEnvelope {
    /// Excavator: donut-shaped reach
    Toroidal {
        inner_radius: f32,
        outer_radius: f32,
        min_depth: f32,
        max_depth: f32,
        swing_arc: (f32, f32),  // Radians from forward
    },
    /// Dozer: blade in front
    Blade {
        width: f32,
        height: f32,
        push_distance: f32,
    },
    /// Loader: bucket reach
    Bucket {
        reach: f32,
        width: f32,
        capacity: f32,  // Cubic meters
    },
}

impl WorkEnvelope {
    /// Check if a world position is within the envelope
    pub fn contains(&self, machine_transform: &Transform, target: Vec3) -> bool {
        let local = machine_transform.rotation.inverse() * (target - machine_transform.translation);
        
        match self {
            Self::Toroidal { inner_radius, outer_radius, min_depth, max_depth, swing_arc } => {
                // Check radial distance (XZ plane)
                let r = (local.x * local.x + local.z * local.z).sqrt();
                if r < *inner_radius || r > *outer_radius {
                    return false;
                }
                
                // Check depth (Y axis, negative is down)
                if -local.y < *min_depth || -local.y > *max_depth {
                    return false;
                }
                
                // Check swing angle
                let angle = local.z.atan2(local.x);
                angle >= swing_arc.0 && angle <= swing_arc.1
            }
            Self::Blade { width, push_distance, .. } => {
                // In front of machine, within blade width
                local.x >= 0.0 && local.x <= *push_distance &&
                local.z.abs() <= width / 2.0
            }
            Self::Bucket { reach, width, .. } => {
                // In front, within reach and width
                let r = (local.x * local.x + local.z * local.z).sqrt();
                r <= *reach && local.z.abs() <= width / 2.0 && local.x >= 0.0
            }
        }
    }
}

/// Operating costs for scoring
#[derive(Component, Clone, Debug)]
pub struct OperatingCosts {
    pub hourly_rate: f32,    // $/hr
    pub cycle_time: f32,     // Seconds per operation
    pub travel_speed: f32,   // m/s
}

/// Current load (for loaders)
#[derive(Component, Default)]
pub struct BucketContents {
    pub volume: f32,         // Cubic meters
    pub material: MaterialId,
}

/// Tracks machine operation for scoring
#[derive(Component, Default)]
pub struct MachineStats {
    pub operating_time: f32,     // Seconds
    pub idle_time: f32,          // Seconds
    pub distance_traveled: f32,  // Meters
    pub volume_moved: f32,       // Cubic meters
}

/// Bundle for spawning machines
#[derive(Bundle)]
pub struct MachineBundle {
    pub id: MachineId,
    pub kind: MachineKind,
    pub activity: MachineActivity,
    pub envelope: WorkEnvelope,
    pub costs: OperatingCosts,
    pub stats: MachineStats,
    pub transform: Transform,
    pub global_transform: GlobalTransform,
    pub visibility: Visibility,
    pub inherited_visibility: InheritedVisibility,
    pub view_visibility: ViewVisibility,
}
```

```rust
// machines/catalog.rs

use super::*;

/// Preset machine configurations matching TerraFirma.jl catalog
pub mod presets {
    use super::*;
    
    /// CAT 320 Excavator
    pub fn cat_320() -> MachineBundle {
        MachineBundle {
            id: MachineId("cat_320".into()),
            kind: MachineKind::Excavator,
            activity: MachineActivity::Idle,
            envelope: WorkEnvelope::Toroidal {
                inner_radius: 2.44,     // 8 ft
                outer_radius: 9.14,     // 30 ft
                min_depth: 0.0,
                max_depth: 6.71,        // 22 ft
                swing_arc: (-2.51, 2.51), // ~144° each side
            },
            costs: OperatingCosts {
                hourly_rate: 150.0,
                cycle_time: 25.0,
                travel_speed: 1.5,      // ~3 mph
            },
            stats: MachineStats::default(),
            transform: Transform::default(),
            global_transform: GlobalTransform::default(),
            visibility: Visibility::Inherited,
            inherited_visibility: InheritedVisibility::default(),
            view_visibility: ViewVisibility::default(),
        }
    }
    
    /// John Deere 450 Dozer
    pub fn jd_450() -> MachineBundle {
        MachineBundle {
            id: MachineId("jd_450".into()),
            kind: MachineKind::Dozer,
            activity: MachineActivity::Idle,
            envelope: WorkEnvelope::Blade {
                width: 3.66,            // 12 ft
                height: 1.22,           // 4 ft
                push_distance: 15.24,   // 50 ft
            },
            costs: OperatingCosts {
                hourly_rate: 100.0,
                cycle_time: 45.0,
                travel_speed: 2.5,      // ~5.5 mph
            },
            stats: MachineStats::default(),
            transform: Transform::default(),
            global_transform: GlobalTransform::default(),
            visibility: Visibility::Inherited,
            inherited_visibility: InheritedVisibility::default(),
            view_visibility: ViewVisibility::default(),
        }
    }
    
    /// Hitachi ZW150 Loader
    pub fn hitachi_zw150() -> MachineBundle {
        MachineBundle {
            id: MachineId("hitachi_zw150".into()),
            kind: MachineKind::Loader,
            activity: MachineActivity::Idle,
            envelope: WorkEnvelope::Bucket {
                reach: 4.0,
                width: 2.5,
                capacity: 1.5,          // ~2 yd³
            },
            costs: OperatingCosts {
                hourly_rate: 90.0,
                cycle_time: 30.0,
                travel_speed: 3.0,
            },
            stats: MachineStats::default(),
            transform: Transform::default(),
            global_transform: GlobalTransform::default(),
            visibility: Visibility::Inherited,
            inherited_visibility: InheritedVisibility::default(),
            view_visibility: ViewVisibility::default(),
        }
    }
    
    /// Create machine bundle from preset name
    pub fn from_preset(name: &str) -> Option<MachineBundle> {
        match name {
            "cat_320" | "cat_320_excavator" => Some(cat_320()),
            "jd_450" | "jd_450_dozer" => Some(jd_450()),
            "hitachi_zw150" | "hitachi_zw150_loader" => Some(hitachi_zw150()),
            _ => None,
        }
    }
}
```

---

## 7. Plan Execution System

### 7.1 Plan Schema (Rust types matching JSON)

```rust
// plan/schema.rs

use bevy::prelude::*;
use serde::{Deserialize, Serialize};

/// Top-level plan structure (Asset)
#[derive(Asset, TypePath, Clone, Debug, Deserialize)]
pub struct ExecutionPlan {
    pub version: String,
    pub metadata: PlanMetadata,
    pub site: SiteDefinition,
    pub machines: Vec<MachineDefinition>,
    pub initial_positions: HashMap<String, InitialPosition>,
    pub steps: Vec<PlanStep>,
    pub results: PlanResults,
    #[serde(default)]
    pub terrain_snapshots: Vec<TerrainSnapshot>,
}

#[derive(Clone, Debug, Deserialize)]
pub struct PlanMetadata {
    pub generated_by: String,
    pub generated_at: String,
    pub site_id: String,
    pub optimization_time_sec: f32,
    pub candidates_evaluated: u32,
    pub valid: bool,
}

#[derive(Clone, Debug, Deserialize)]
pub struct SiteDefinition {
    pub bounds: Bounds3D,
    pub terrain_resolution: f32,
    pub terrain_dims: [u32; 3],
    pub initial_terrain: String,  // Base64 RLE encoded
}

#[derive(Clone, Debug, Deserialize)]
pub struct Bounds3D {
    pub min: [f32; 3],
    pub max: [f32; 3],
}

impl Bounds3D {
    pub fn to_aabb(&self) -> Aabb {
        let min = Vec3::from(self.min);
        let max = Vec3::from(self.max);
        Aabb {
            center: (min + max) / 2.0,
            half_extents: (max - min) / 2.0,
        }
    }
}

#[derive(Clone, Debug, Deserialize)]
pub struct MachineDefinition {
    pub id: String,
    pub kind: String,
    pub preset: String,
    #[serde(default)]
    pub envelope: Option<EnvelopeOverride>,
    #[serde(default)]
    pub costs: Option<CostsOverride>,
}

#[derive(Clone, Debug, Deserialize)]
pub struct EnvelopeOverride {
    #[serde(rename = "type")]
    pub envelope_type: String,
    pub inner_radius: Option<f32>,
    pub outer_radius: Option<f32>,
    pub max_depth: Option<f32>,
    // ... other fields
}

#[derive(Clone, Debug, Deserialize)]
pub struct CostsOverride {
    pub hourly_rate: Option<f32>,
    pub cycle_time: Option<f32>,
}

#[derive(Clone, Debug, Deserialize)]
pub struct InitialPosition {
    pub position: [f32; 3],
    pub orientation: f32,
}

#[derive(Clone, Debug, Deserialize)]
pub struct PlanStep {
    pub timestamp: f32,
    pub machine: String,
    pub action: PlannedAction,
}

#[derive(Clone, Debug, Deserialize)]
#[serde(tag = "type")]
pub enum PlannedAction {
    MoveTo {
        position: [f32; 3],
        orientation: Option<f32>,
        #[serde(default)]
        path_hint: Option<Vec<[f32; 3]>>,
    },
    Excavate {
        target_volume: Bounds3D,
        expected_yield: Option<f32>,
    },
    Dump {
        target_position: [f32; 3],
        volume: Option<f32>,
    },
    Push {
        direction: [f32; 3],
        distance: f32,
    },
    Scoop {
        target_position: [f32; 3],
    },
    Idle {
        duration: f32,
    },
}

#[derive(Clone, Debug, Deserialize)]
pub struct PlanResults {
    pub valid: bool,
    pub total_time_hrs: f32,
    pub total_cost_usd: f32,
    pub dirt_moved_yd3: f32,
    #[serde(default)]
    pub per_machine: HashMap<String, MachineResults>,
    #[serde(default)]
    pub violations: Vec<Violation>,
}

#[derive(Clone, Debug, Deserialize)]
pub struct MachineResults {
    pub operating_time: f32,
    pub idle_time: f32,
    pub distance_traveled: f32,
    pub volume_moved: f32,
    pub cost: f32,
}

#[derive(Clone, Debug, Deserialize)]
pub struct Violation {
    pub step: usize,
    pub machine: String,
    pub description: String,
}

#[derive(Clone, Debug, Deserialize)]
pub struct TerrainSnapshot {
    pub timestamp: f32,
    pub terrain: String,  // Base64 RLE encoded
}
```

### 7.2 Plan Loader

```rust
// plan/loader.rs

use super::*;
use bevy::{
    asset::{AssetLoader, LoadContext, io::Reader},
    prelude::*,
};

#[derive(Default)]
pub struct PlanLoader;

impl AssetLoader for PlanLoader {
    type Asset = ExecutionPlan;
    type Settings = ();
    type Error = PlanLoadError;
    
    async fn load(
        &self,
        reader: &mut dyn Reader,
        _settings: &Self::Settings,
        _load_context: &mut LoadContext<'_>,
    ) -> Result<Self::Asset, Self::Error> {
        let mut bytes = Vec::new();
        reader.read_to_end(&mut bytes).await?;
        
        let plan: ExecutionPlan = serde_json::from_slice(&bytes)?;
        
        // Validate version
        if !plan.version.starts_with("1.") {
            return Err(PlanLoadError::UnsupportedVersion(plan.version.clone()));
        }
        
        Ok(plan)
    }
    
    fn extensions(&self) -> &[&str] {
        &["plan.json", "earthworks.json"]
    }
}

#[derive(Debug, thiserror::Error)]
pub enum PlanLoadError {
    #[error("IO error: {0}")]
    Io(#[from] std::io::Error),
    #[error("JSON parse error: {0}")]
    Json(#[from] serde_json::Error),
    #[error("Unsupported plan version: {0}")]
    UnsupportedVersion(String),
}
```

### 7.3 Playback State

```rust
// plan/executor.rs

use super::*;
use bevy::prelude::*;

/// Controls plan playback
#[derive(Resource)]
pub struct PlanPlayback {
    /// Current playback time in seconds
    pub current_time: f32,
    /// Playback speed multiplier (1.0 = realtime)
    pub speed: f32,
    /// Whether playback is active
    pub playing: bool,
    /// Loop when reaching end
    pub loop_enabled: bool,
    /// Index of next step to execute
    pub next_step_index: usize,
    /// Plan duration (set when plan loads)
    pub duration: f32,
}

impl Default for PlanPlayback {
    fn default() -> Self {
        Self {
            current_time: 0.0,
            speed: 1.0,
            playing: false,
            loop_enabled: false,
            next_step_index: 0,
            duration: 0.0,
        }
    }
}

impl PlanPlayback {
    pub fn play(&mut self) {
        self.playing = true;
    }
    
    pub fn pause(&mut self) {
        self.playing = false;
    }
    
    pub fn toggle(&mut self) {
        self.playing = !self.playing;
    }
    
    pub fn seek(&mut self, time: f32) {
        self.current_time = time.clamp(0.0, self.duration);
        // Note: next_step_index needs to be recalculated by executor
    }
    
    pub fn reset(&mut self) {
        self.current_time = 0.0;
        self.next_step_index = 0;
    }
    
    pub fn progress(&self) -> f32 {
        if self.duration > 0.0 {
            self.current_time / self.duration
        } else {
            0.0
        }
    }
}

/// Marker for the currently loaded plan
#[derive(Resource)]
pub struct LoadedPlan {
    pub handle: Handle<ExecutionPlan>,
    pub initialized: bool,
}

/// System: Initialize terrain and machines when plan loads
pub fn plan_loader_system(
    mut commands: Commands,
    mut loaded_plan: Option<ResMut<LoadedPlan>>,
    plans: Res<Assets<ExecutionPlan>>,
    mut terrain: ResMut<VoxelTerrain>,
    mut playback: ResMut<PlanPlayback>,
    mut meshes: ResMut<Assets<Mesh>>,
    mut materials: ResMut<Assets<StandardMaterial>>,
    existing_machines: Query<Entity, With<MachineId>>,
) {
    let Some(ref mut loaded) = loaded_plan else { return };
    if loaded.initialized { return }
    
    let Some(plan) = plans.get(&loaded.handle) else { return };
    
    // Clear existing machines
    for entity in existing_machines.iter() {
        commands.entity(entity).despawn_recursive();
    }
    
    // Initialize terrain
    terrain.initialize_from_plan(plan);
    
    // Spawn machines
    for machine_def in &plan.machines {
        let mut bundle = presets::from_preset(&machine_def.preset)
            .unwrap_or_else(|| presets::cat_320());  // Fallback
        
        bundle.id = MachineId(machine_def.id.clone());
        
        // Set initial position
        if let Some(init) = plan.initial_positions.get(&machine_def.id) {
            bundle.transform = Transform::from_translation(Vec3::from(init.position))
                .with_rotation(Quat::from_rotation_y(init.orientation));
        }
        
        // Spawn with visual mesh (placeholder cube for now)
        commands.spawn(bundle)
            .insert(Mesh3d(meshes.add(Cuboid::new(4.0, 2.0, 2.5))))
            .insert(MeshMaterial3d(materials.add(StandardMaterial {
                base_color: Color::srgb(0.9, 0.7, 0.1),
                ..default()
            })));
    }
    
    // Set playback duration
    if let Some(last_step) = plan.steps.last() {
        playback.duration = last_step.timestamp + 60.0;  // Add buffer
    }
    
    playback.reset();
    loaded.initialized = true;
    
    info!("Plan loaded: {} steps, {:.1}s duration", 
          plan.steps.len(), playback.duration);
}

/// System: Execute plan steps as time advances
pub fn plan_executor_system(
    time: Res<Time>,
    mut playback: ResMut<PlanPlayback>,
    loaded_plan: Option<Res<LoadedPlan>>,
    plans: Res<Assets<ExecutionPlan>>,
    mut terrain: ResMut<VoxelTerrain>,
    mut machines: Query<(
        &MachineId,
        &mut Transform,
        &mut MachineActivity,
        &mut MachineStats,
        &OperatingCosts,
    )>,
    mut step_events: EventWriter<PlanStepEvent>,
    mut terrain_events: EventWriter<TerrainModifiedEvent>,
) {
    if !playback.playing { return }
    
    let Some(ref loaded) = loaded_plan else { return };
    let Some(plan) = plans.get(&loaded.handle) else { return };
    
    // Advance time
    let dt = time.delta_secs() * playback.speed;
    playback.current_time += dt;
    
    // Check for end of plan
    if playback.current_time >= playback.duration {
        if playback.loop_enabled {
            playback.reset();
        } else {
            playback.playing = false;
            playback.current_time = playback.duration;
        }
        return;
    }
    
    // Execute steps that have become active
    while playback.next_step_index < plan.steps.len() {
        let step = &plan.steps[playback.next_step_index];
        
        if step.timestamp > playback.current_time {
            break;  // Not time yet
        }
        
        // Find the machine
        let machine_result = machines.iter_mut()
            .find(|(id, ..)| id.0 == step.machine);
        
        if let Some((_, mut transform, mut activity, mut stats, costs)) = machine_result {
            let result = execute_step(
                &step.action,
                &mut transform,
                &mut activity,
                &mut stats,
                costs,
                &mut terrain,
                &mut terrain_events,
            );
            
            step_events.send(PlanStepEvent {
                step_index: playback.next_step_index,
                step: step.clone(),
                result,
            });
        }
        
        playback.next_step_index += 1;
    }
    
    // Update machine animations
    update_machine_activities(dt, &mut machines);
}

fn execute_step(
    action: &PlannedAction,
    transform: &mut Transform,
    activity: &mut MachineActivity,
    stats: &mut MachineStats,
    costs: &OperatingCosts,
    terrain: &mut VoxelTerrain,
    terrain_events: &mut EventWriter<TerrainModifiedEvent>,
) -> StepResult {
    match action {
        PlannedAction::MoveTo { position, orientation, path_hint } => {
            let to = Vec3::from(*position);
            let from = transform.translation;
            let distance = from.distance(to);
            
            *activity = MachineActivity::Traveling {
                from,
                to,
                progress: 0.0,
                path: path_hint.clone().map(|p| p.iter().map(|v| Vec3::from(*v)).collect()),
            };
            
            if let Some(orient) = orientation {
                transform.rotation = Quat::from_rotation_y(*orient);
            }
            
            stats.distance_traveled += distance;
            
            StepResult {
                duration: distance / costs.travel_speed,
                volume_moved: 0.0,
                success: true,
            }
        }
        
        PlannedAction::Excavate { target_volume, expected_yield } => {
            let aabb = target_volume.to_aabb();
            let volume = terrain.excavate(&AabbShape(aabb));
            
            *activity = MachineActivity::Excavating {
                target: aabb,
                progress: 0.0,
                expected_yield: expected_yield.unwrap_or(volume),
            };
            
            stats.volume_moved += volume;
            stats.operating_time += costs.cycle_time;
            
            // Emit terrain event
            let chunk_pos = terrain.world_to_chunk(aabb.center.into());
            terrain_events.send(TerrainModifiedEvent {
                chunk_pos,
                operation: TerrainOperation::Excavate { material: MaterialId::Dirt },
                volume_changed: volume,
            });
            
            StepResult {
                duration: costs.cycle_time,
                volume_moved: volume,
                success: true,
            }
        }
        
        PlannedAction::Dump { target_position, volume } => {
            let pos = Vec3::from(*target_position);
            let vol = volume.unwrap_or(1.0);
            
            terrain.fill(pos, vol, MaterialId::Dirt);
            
            *activity = MachineActivity::Dumping {
                target: pos,
                progress: 0.0,
                volume: vol,
            };
            
            StepResult {
                duration: costs.cycle_time * 0.5,
                volume_moved: vol,
                success: true,
            }
        }
        
        PlannedAction::Idle { duration } => {
            *activity = MachineActivity::Idle;
            stats.idle_time += duration;
            
            StepResult {
                duration: *duration,
                volume_moved: 0.0,
                success: true,
            }
        }
        
        _ => StepResult {
            duration: 0.0,
            volume_moved: 0.0,
            success: false,
        },
    }
}

fn update_machine_activities(
    dt: f32,
    machines: &mut Query<(
        &MachineId,
        &mut Transform,
        &mut MachineActivity,
        &mut MachineStats,
        &OperatingCosts,
    )>,
) {
    for (_, mut transform, mut activity, _, costs) in machines.iter_mut() {
        match activity.as_mut() {
            MachineActivity::Traveling { from, to, progress, path } => {
                let travel_time = from.distance(*to) / costs.travel_speed;
                *progress += dt / travel_time;
                
                if *progress >= 1.0 {
                    transform.translation = *to;
                    *activity = MachineActivity::Idle;
                } else {
                    // Interpolate position
                    if let Some(path_points) = path {
                        // Follow path with Catmull-Rom or linear segments
                        transform.translation = interpolate_path(path_points, *progress);
                    } else {
                        transform.translation = from.lerp(*to, *progress);
                    }
                }
            }
            
            MachineActivity::Excavating { progress, .. } => {
                *progress += dt / costs.cycle_time;
                if *progress >= 1.0 {
                    *activity = MachineActivity::Idle;
                }
            }
            
            MachineActivity::Dumping { progress, .. } => {
                *progress += dt / (costs.cycle_time * 0.5);
                if *progress >= 1.0 {
                    *activity = MachineActivity::Idle;
                }
            }
            
            _ => {}
        }
    }
}

fn interpolate_path(points: &[Vec3], t: f32) -> Vec3 {
    if points.is_empty() {
        return Vec3::ZERO;
    }
    if points.len() == 1 {
        return points[0];
    }
    
    let segment_count = points.len() - 1;
    let total_t = t * segment_count as f32;
    let segment = (total_t.floor() as usize).min(segment_count - 1);
    let local_t = total_t - segment as f32;
    
    points[segment].lerp(points[segment + 1], local_t)
}
```

---

## 8. Rendering Pipeline

### 8.1 Greedy Meshing

```rust
// terrain/meshing.rs

use super::*;
use bevy::prelude::*;
use bevy::render::mesh::{Indices, PrimitiveTopology, VertexAttributeValues};

/// Generate mesh for a chunk using greedy meshing algorithm
pub fn generate_chunk_mesh(
    chunk: &Chunk,
    terrain: &VoxelTerrain,
) -> Mesh {
    let mut positions: Vec<[f32; 3]> = Vec::new();
    let mut normals: Vec<[f32; 3]> = Vec::new();
    let mut uvs: Vec<[f32; 2]> = Vec::new();
    let mut colors: Vec<[f32; 4]> = Vec::new();
    let mut indices: Vec<u32> = Vec::new();
    
    let voxel_size = terrain.config.voxel_size;
    let chunk_world_origin = chunk.position.as_vec3() * 
        (terrain.config.chunk_size as f32 * voxel_size);
    
    // Process each axis direction
    for axis in 0..3 {
        for dir in [false, true] {  // negative, positive
            greedy_mesh_face(
                chunk,
                terrain,
                axis,
                dir,
                voxel_size,
                chunk_world_origin,
                &mut positions,
                &mut normals,
                &mut uvs,
                &mut colors,
                &mut indices,
            );
        }
    }
    
    let mut mesh = Mesh::new(PrimitiveTopology::TriangleList, Default::default());
    
    mesh.insert_attribute(Mesh::ATTRIBUTE_POSITION, positions);
    mesh.insert_attribute(Mesh::ATTRIBUTE_NORMAL, normals);
    mesh.insert_attribute(Mesh::ATTRIBUTE_UV_0, uvs);
    mesh.insert_attribute(Mesh::ATTRIBUTE_COLOR, colors);
    mesh.insert_indices(Indices::U32(indices));
    
    mesh
}

fn greedy_mesh_face(
    chunk: &Chunk,
    terrain: &VoxelTerrain,
    axis: usize,      // 0=X, 1=Y, 2=Z
    positive: bool,   // Face direction
    voxel_size: f32,
    chunk_origin: Vec3,
    positions: &mut Vec<[f32; 3]>,
    normals: &mut Vec<[f32; 3]>,
    uvs: &mut Vec<[f32; 2]>,
    colors: &mut Vec<[f32; 4]>,
    indices: &mut Vec<u32>,
) {
    let size = terrain.config.chunk_size as usize;
    
    // Determine the two axes perpendicular to face normal
    let (u_axis, v_axis) = match axis {
        0 => (2, 1), // X face: Z and Y
        1 => (0, 2), // Y face: X and Z
        2 => (0, 1), // Z face: X and Y
        _ => unreachable!(),
    };
    
    // Normal direction
    let normal: [f32; 3] = {
        let mut n = [0.0; 3];
        n[axis] = if positive { 1.0 } else { -1.0 };
        n
    };
    
    // Process each slice perpendicular to axis
    for d in 0..size {
        // Build mask of faces to render in this slice
        let mut mask: Vec<Option<Voxel>> = vec![None; size * size];
        
        for v in 0..size {
            for u in 0..size {
                let mut pos = [0usize; 3];
                pos[axis] = d;
                pos[u_axis] = u;
                pos[v_axis] = v;
                
                let voxel = chunk.get(UVec3::new(pos[0] as u32, pos[1] as u32, pos[2] as u32));
                
                if !voxel.is_solid() {
                    continue;
                }
                
                // Check if face is visible (neighbor is empty)
                let neighbor_d = if positive { d + 1 } else { d.wrapping_sub(1) };
                let neighbor_empty = if neighbor_d >= size {
                    true  // Edge of chunk, assume visible (could check neighbor chunk)
                } else {
                    let mut neighbor_pos = pos;
                    neighbor_pos[axis] = neighbor_d;
                    let neighbor = chunk.get(UVec3::new(
                        neighbor_pos[0] as u32,
                        neighbor_pos[1] as u32,
                        neighbor_pos[2] as u32,
                    ));
                    !neighbor.is_solid()
                };
                
                if neighbor_empty {
                    mask[v * size + u] = Some(voxel);
                }
            }
        }
        
        // Greedy merge faces with same material
        let mut visited = vec![false; size * size];
        
        for v in 0..size {
            for u in 0..size {
                let idx = v * size + u;
                
                if visited[idx] || mask[idx].is_none() {
                    continue;
                }
                
                let voxel = mask[idx].unwrap();
                
                // Find width (u direction)
                let mut width = 1;
                while u + width < size {
                    let next_idx = v * size + u + width;
                    if visited[next_idx] || mask[next_idx] != Some(voxel) {
                        break;
                    }
                    width += 1;
                }
                
                // Find height (v direction)
                let mut height = 1;
                'outer: while v + height < size {
                    for du in 0..width {
                        let next_idx = (v + height) * size + u + du;
                        if visited[next_idx] || mask[next_idx] != Some(voxel) {
                            break 'outer;
                        }
                    }
                    height += 1;
                }
                
                // Mark as visited
                for dv in 0..height {
                    for du in 0..width {
                        visited[(v + dv) * size + u + du] = true;
                    }
                }
                
                // Generate quad
                let base_idx = positions.len() as u32;
                
                // Calculate world positions for quad corners
                let mut corner = [0.0f32; 3];
                corner[axis] = (d as f32 + if positive { 1.0 } else { 0.0 }) * voxel_size;
                corner[u_axis] = u as f32 * voxel_size;
                corner[v_axis] = v as f32 * voxel_size;
                
                let corner_world = chunk_origin + Vec3::from(corner);
                
                let u_offset = {
                    let mut o = Vec3::ZERO;
                    o[u_axis] = width as f32 * voxel_size;
                    o
                };
                
                let v_offset = {
                    let mut o = Vec3::ZERO;
                    o[v_axis] = height as f32 * voxel_size;
                    o
                };
                
                // Four corners
                let p0 = corner_world;
                let p1 = corner_world + u_offset;
                let p2 = corner_world + u_offset + v_offset;
                let p3 = corner_world + v_offset;
                
                positions.extend([p0.to_array(), p1.to_array(), p2.to_array(), p3.to_array()]);
                normals.extend([normal, normal, normal, normal]);
                uvs.extend([[0.0, 0.0], [1.0, 0.0], [1.0, 1.0], [0.0, 1.0]]);
                
                // Color based on material
                let color = voxel.material.color();
                let color_arr = [color.r(), color.g(), color.b(), color.a()];
                colors.extend([color_arr, color_arr, color_arr, color_arr]);
                
                // Indices (two triangles)
                if positive {
                    indices.extend([
                        base_idx, base_idx + 1, base_idx + 2,
                        base_idx, base_idx + 2, base_idx + 3,
                    ]);
                } else {
                    indices.extend([
                        base_idx, base_idx + 2, base_idx + 1,
                        base_idx, base_idx + 3, base_idx + 2,
                    ]);
                }
            }
        }
    }
}

/// System: Generate meshes for dirty chunks
pub fn mesh_generation_system(
    mut commands: Commands,
    mut terrain: ResMut<VoxelTerrain>,
    mut meshes: ResMut<Assets<Mesh>>,
    mut materials: ResMut<Assets<StandardMaterial>>,
    chunk_entities: Query<(Entity, &ChunkMarker)>,
) {
    let dirty: Vec<IVec3> = terrain.dirty_chunks().collect();
    let max_per_frame = terrain.config.max_mesh_per_frame as usize;
    
    for chunk_pos in dirty.into_iter().take(max_per_frame) {
        // Get or create chunk entity
        let entity = chunk_entities.iter()
            .find(|(_, marker)| marker.0 == chunk_pos)
            .map(|(e, _)| e);
        
        if let Some(chunk) = terrain.chunks.get(&chunk_pos) {
            if chunk.is_empty() {
                // Despawn empty chunk entity
                if let Some(entity) = entity {
                    commands.entity(entity).despawn_recursive();
                }
            } else {
                // Generate mesh
                let mesh = generate_chunk_mesh(chunk, &terrain);
                let mesh_handle = meshes.add(mesh);
                
                if let Some(entity) = entity {
                    // Update existing
                    commands.entity(entity).insert(Mesh3d(mesh_handle.clone()));
                } else {
                    // Spawn new
                    let chunk_world_pos = terrain.chunk_to_world(chunk_pos);
                    commands.spawn((
                        ChunkMarker(chunk_pos),
                        Mesh3d(mesh_handle.clone()),
                        MeshMaterial3d(materials.add(StandardMaterial {
                            base_color: Color::WHITE,
                            perceptual_roughness: 0.9,
                            ..default()
                        })),
                        Transform::from_translation(chunk_world_pos),
                        GlobalTransform::default(),
                        Visibility::Inherited,
                        InheritedVisibility::default(),
                        ViewVisibility::default(),
                    ));
                }
                
                terrain.set_chunk_mesh(chunk_pos, mesh_handle);
            }
        }
        
        terrain.mark_clean(chunk_pos);
    }
}

/// Marker component for chunk entities
#[derive(Component)]
pub struct ChunkMarker(pub IVec3);
```

### 8.2 Machine Gizmos

```rust
// machines/gizmos.rs

use super::*;
use bevy::prelude::*;

/// Draw work envelope debug visualization
pub fn draw_work_envelopes(
    mut gizmos: Gizmos,
    machines: Query<(&Transform, &WorkEnvelope, &MachineActivity)>,
    config: Res<EarthworksConfig>,
) {
    if !config.enable_debug_visuals {
        return;
    }
    
    for (transform, envelope, activity) in machines.iter() {
        let color = match activity {
            MachineActivity::Idle => Color::srgba(1.0, 1.0, 0.0, 0.3),
            MachineActivity::Excavating { .. } => Color::srgba(0.0, 1.0, 0.0, 0.5),
            MachineActivity::Traveling { .. } => Color::srgba(0.0, 0.5, 1.0, 0.3),
            _ => Color::srgba(1.0, 0.5, 0.0, 0.3),
        };
        
        match envelope {
            WorkEnvelope::Toroidal { inner_radius, outer_radius, max_depth, swing_arc, .. } => {
                draw_toroid_envelope(
                    &mut gizmos,
                    transform,
                    *inner_radius,
                    *outer_radius,
                    *max_depth,
                    *swing_arc,
                    color,
                );
            }
            WorkEnvelope::Blade { width, push_distance, height } => {
                draw_blade_envelope(
                    &mut gizmos,
                    transform,
                    *width,
                    *push_distance,
                    *height,
                    color,
                );
            }
            WorkEnvelope::Bucket { reach, width, .. } => {
                draw_bucket_envelope(
                    &mut gizmos,
                    transform,
                    *reach,
                    *width,
                    color,
                );
            }
        }
    }
}

fn draw_toroid_envelope(
    gizmos: &mut Gizmos,
    transform: &Transform,
    inner_radius: f32,
    outer_radius: f32,
    max_depth: f32,
    swing_arc: (f32, f32),
    color: Color,
) {
    let segments = 32;
    let pos = transform.translation;
    let rot = transform.rotation;
    
    // Draw outer arc at surface
    draw_arc(gizmos, pos, rot, outer_radius, swing_arc, 0.0, color, segments);
    
    // Draw inner arc at surface
    draw_arc(gizmos, pos, rot, inner_radius, swing_arc, 0.0, color, segments);
    
    // Draw outer arc at max depth
    let depth_offset = Vec3::new(0.0, -max_depth, 0.0);
    draw_arc(gizmos, pos + depth_offset, rot, outer_radius, swing_arc, 0.0, color, segments);
    
    // Draw radial lines at swing limits
    for angle in [swing_arc.0, swing_arc.1] {
        let dir = rot * Vec3::new(angle.cos(), 0.0, angle.sin());
        gizmos.line(
            pos + dir * inner_radius,
            pos + dir * outer_radius,
            color,
        );
        gizmos.line(
            pos + depth_offset + dir * inner_radius,
            pos + depth_offset + dir * outer_radius,
            color,
        );
    }
    
    // Vertical lines at corners
    for angle in [swing_arc.0, swing_arc.1] {
        let dir = rot * Vec3::new(angle.cos(), 0.0, angle.sin());
        for r in [inner_radius, outer_radius] {
            gizmos.line(
                pos + dir * r,
                pos + depth_offset + dir * r,
                color,
            );
        }
    }
}

fn draw_arc(
    gizmos: &mut Gizmos,
    center: Vec3,
    rotation: Quat,
    radius: f32,
    arc: (f32, f32),
    y_offset: f32,
    color: Color,
    segments: u32,
) {
    let arc_length = arc.1 - arc.0;
    
    for i in 0..segments {
        let t0 = i as f32 / segments as f32;
        let t1 = (i + 1) as f32 / segments as f32;
        
        let angle0 = arc.0 + t0 * arc_length;
        let angle1 = arc.0 + t1 * arc_length;
        
        let p0 = center + rotation * Vec3::new(
            angle0.cos() * radius,
            y_offset,
            angle0.sin() * radius,
        );
        let p1 = center + rotation * Vec3::new(
            angle1.cos() * radius,
            y_offset,
            angle1.sin() * radius,
        );
        
        gizmos.line(p0, p1, color);
    }
}

fn draw_blade_envelope(
    gizmos: &mut Gizmos,
    transform: &Transform,
    width: f32,
    push_distance: f32,
    height: f32,
    color: Color,
) {
    let pos = transform.translation;
    let forward = transform.forward();
    let right = transform.right();
    let up = transform.up();
    
    // Blade rectangle
    let half_width = width / 2.0;
    let corners = [
        pos + right * half_width,
        pos - right * half_width,
        pos - right * half_width + forward * push_distance,
        pos + right * half_width + forward * push_distance,
    ];
    
    // Bottom rectangle
    for i in 0..4 {
        gizmos.line(corners[i], corners[(i + 1) % 4], color);
    }
    
    // Top rectangle
    for i in 0..4 {
        gizmos.line(corners[i] + up * height, corners[(i + 1) % 4] + up * height, color);
    }
    
    // Vertical edges
    for corner in &corners {
        gizmos.line(*corner, *corner + up * height, color);
    }
}

fn draw_bucket_envelope(
    gizmos: &mut Gizmos,
    transform: &Transform,
    reach: f32,
    width: f32,
    color: Color,
) {
    let pos = transform.translation;
    let rot = transform.rotation;
    
    // Semi-circular arc in front
    let segments = 16;
    let half_width = width / 2.0;
    
    for i in 0..segments {
        let t0 = i as f32 / segments as f32;
        let t1 = (i + 1) as f32 / segments as f32;
        
        let angle0 = -std::f32::consts::FRAC_PI_2 + t0 * std::f32::consts::PI;
        let angle1 = -std::f32::consts::FRAC_PI_2 + t1 * std::f32::consts::PI;
        
        let p0 = pos + rot * Vec3::new(angle0.cos() * reach, 0.0, angle0.sin() * reach);
        let p1 = pos + rot * Vec3::new(angle1.cos() * reach, 0.0, angle1.sin() * reach);
        
        gizmos.line(p0, p1, color);
    }
    
    // Side lines
    gizmos.line(pos, pos + rot * Vec3::new(0.0, 0.0, half_width), color);
    gizmos.line(pos, pos + rot * Vec3::new(0.0, 0.0, -half_width), color);
}
```

---

## 9. User Interface

### 9.1 UI Plugin

```rust
// ui/mod.rs

use bevy::prelude::*;
use bevy_egui::{egui, EguiContexts, EguiPlugin};

pub mod timeline;
pub mod overlay;
pub mod inspector;

pub struct EarthworksUiPlugin;

impl Plugin for EarthworksUiPlugin {
    fn build(&self, app: &mut App) {
        app.add_plugins(EguiPlugin)
           .add_systems(Update, (
               timeline::timeline_ui,
               overlay::score_overlay_ui,
               inspector::machine_inspector_ui,
           ));
    }
}
```

### 9.2 Timeline UI

```rust
// ui/timeline.rs

use super::*;
use crate::plan::PlanPlayback;

pub fn timeline_ui(
    mut contexts: EguiContexts,
    mut playback: ResMut<PlanPlayback>,
    keys: Res<ButtonInput<KeyCode>>,
) {
    // Keyboard shortcuts
    if keys.just_pressed(KeyCode::Space) {
        playback.toggle();
    }
    if keys.just_pressed(KeyCode::KeyR) {
        playback.reset();
    }
    if keys.just_pressed(KeyCode::BracketLeft) {
        playback.speed = (playback.speed / 2.0).max(0.125);
    }
    if keys.just_pressed(KeyCode::BracketRight) {
        playback.speed = (playback.speed * 2.0).min(32.0);
    }
    
    egui::TopBottomPanel::bottom("timeline_panel")
        .resizable(false)
        .show(contexts.ctx_mut(), |ui| {
            ui.horizontal(|ui| {
                // Play/Pause button
                let icon = if playback.playing { "⏸" } else { "▶" };
                if ui.button(icon).clicked() {
                    playback.toggle();
                }
                
                // Reset button
                if ui.button("⏮").clicked() {
                    playback.reset();
                }
                
                // Time display
                let minutes = (playback.current_time / 60.0).floor() as u32;
                let seconds = (playback.current_time % 60.0).floor() as u32;
                let total_minutes = (playback.duration / 60.0).floor() as u32;
                let total_seconds = (playback.duration % 60.0).floor() as u32;
                
                ui.label(format!(
                    "{:02}:{:02} / {:02}:{:02}",
                    minutes, seconds, total_minutes, total_seconds
                ));
                
                // Timeline scrubber
                ui.spacing_mut().slider_width = ui.available_width() - 200.0;
                let mut time = playback.current_time;
                let response = ui.add(
                    egui::Slider::new(&mut time, 0.0..=playback.duration)
                        .show_value(false)
                        .trailing_fill(true)
                );
                if response.changed() {
                    playback.seek(time);
                }
                
                // Speed control
                ui.label("Speed:");
                ui.add(
                    egui::DragValue::new(&mut playback.speed)
                        .speed(0.1)
                        .range(0.125..=32.0)
                        .suffix("x")
                );
                
                // Loop toggle
                ui.checkbox(&mut playback.loop_enabled, "🔁");
            });
        });
}
```

### 9.3 Score Overlay

```rust
// ui/overlay.rs

use super::*;
use crate::scoring::SimulationScore;
use crate::plan::{ExecutionPlan, LoadedPlan};

pub fn score_overlay_ui(
    mut contexts: EguiContexts,
    score: Res<SimulationScore>,
    loaded_plan: Option<Res<LoadedPlan>>,
    plans: Res<Assets<ExecutionPlan>>,
) {
    egui::Window::new("Plan Results")
        .anchor(egui::Align2::RIGHT_TOP, [-10.0, 10.0])
        .resizable(false)
        .collapsible(true)
        .show(contexts.ctx_mut(), |ui| {
            // Expected results from plan
            if let Some(ref loaded) = loaded_plan {
                if let Some(plan) = plans.get(&loaded.handle) {
                    ui.heading("Expected");
                    ui.label(format!("Cost: ${:.2}", plan.results.total_cost_usd));
                    ui.label(format!("Time: {:.1} hrs", plan.results.total_time_hrs));
                    ui.label(format!("Volume: {:.1} yd³", plan.results.dirt_moved_yd3));
                    
                    if !plan.results.valid {
                        ui.colored_label(egui::Color32::RED, "⚠ Plan has violations");
                    }
                    
                    ui.separator();
                }
            }
            
            // Live tracking
            ui.heading("Current");
            ui.label(format!("Cost: ${:.2}", score.total_cost));
            ui.label(format!("Time: {:.1} hrs", score.total_time / 3600.0));
            ui.label(format!("Volume: {:.1} m³", score.volume_moved));
            
            // Per-machine breakdown
            if !score.per_machine.is_empty() {
                ui.separator();
                ui.heading("By Machine");
                
                for (id, stats) in &score.per_machine {
                    ui.collapsing(id, |ui| {
                        ui.label(format!("Operating: {:.1} min", stats.operating_time / 60.0));
                        ui.label(format!("Idle: {:.1} min", stats.idle_time / 60.0));
                        ui.label(format!("Distance: {:.1} m", stats.distance_traveled));
                        ui.label(format!("Volume: {:.1} m³", stats.volume_moved));
                        ui.label(format!("Cost: ${:.2}", stats.cost));
                    });
                }
            }
        });
}
```

---

## 10. Asset Pipeline

### 10.1 Terrain Data Encoding/Decoding

```rust
// terrain/encoding.rs

use base64::{Engine, engine::general_purpose::STANDARD};

/// Decode RLE-encoded terrain data from plan JSON
pub fn decode_terrain(encoded: &str) -> Vec<u8> {
    let bytes = STANDARD.decode(encoded).unwrap_or_default();
    
    // RLE decode: pairs of (value, count)
    let mut result = Vec::new();
    let mut i = 0;
    
    while i + 1 < bytes.len() {
        let value = bytes[i];
        let count = bytes[i + 1] as usize;
        result.extend(std::iter::repeat(value).take(count));
        i += 2;
    }
    
    result
}

/// Encode terrain data to RLE for export
pub fn encode_terrain(data: &[u8]) -> String {
    let mut bytes = Vec::new();
    
    if data.is_empty() {
        return STANDARD.encode(&bytes);
    }
    
    let mut current = data[0];
    let mut count: u8 = 1;
    
    for &value in &data[1..] {
        if value == current && count < 255 {
            count += 1;
        } else {
            bytes.push(current);
            bytes.push(count);
            current = value;
            count = 1;
        }
    }
    
    bytes.push(current);
    bytes.push(count);
    
    STANDARD.encode(&bytes)
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_roundtrip() {
        let original = vec![0, 0, 0, 1, 1, 2, 2, 2, 2, 0];
        let encoded = encode_terrain(&original);
        let decoded = decode_terrain(&encoded);
        assert_eq!(original, decoded);
    }
}
```

---

## 11. Performance Requirements

### 11.1 Targets

| Metric | Target | Measurement |
|--------|--------|-------------|
| Terrain init (80×80×8) | < 100ms | Time from plan load to first render |
| Mesh generation (per chunk) | < 5ms | Single chunk greedy mesh |
| Frame time (60 FPS) | < 16.6ms | With UI, 3 machines, full terrain |
| Memory (terrain) | < 100MB | 80×80×8 site at 1ft resolution |
| Memory (total) | < 500MB | Full app with assets |
| Plan load | < 50ms | JSON parse + terrain decode |

### 11.2 Optimization Strategies

1. **Chunk-based terrain:** Only mesh modified chunks
2. **Greedy meshing:** Minimize triangle count
3. **Async mesh generation:** Don't block main thread
4. **Frustum culling:** Bevy handles this automatically
5. **LOD (future):** Reduce detail for distant chunks
6. **Instancing (future):** For repeated elements

### 11.3 Profiling Points

```rust
// Add to systems for profiling
#[cfg(feature = "trace")]
use bevy::log::trace_span;

pub fn mesh_generation_system(/* ... */) {
    #[cfg(feature = "trace")]
    let _span = trace_span!("mesh_generation").entered();
    
    // ... system code
}
```

---

## 12. Testing Strategy

### 12.1 Unit Tests

```rust
// tests/terrain_tests.rs

use bevy_earthworks::terrain::*;

#[test]
fn test_voxel_operations() {
    let mut terrain = VoxelTerrain::default();
    
    // Set and get
    terrain.set_voxel(Vec3::new(1.0, 1.0, 1.0), Voxel::solid(MaterialId::Dirt));
    let voxel = terrain.get_voxel(Vec3::new(1.0, 1.0, 1.0));
    assert!(voxel.unwrap().is_solid());
}

#[test]
fn test_excavate_volume() {
    let mut terrain = VoxelTerrain::default();
    
    // Fill a region
    for x in 0..10 {
        for y in 0..10 {
            for z in 0..10 {
                let pos = Vec3::new(x as f32 * 0.3048, y as f32 * 0.3048, z as f32 * 0.3048);
                terrain.set_voxel(pos, Voxel::solid(MaterialId::Dirt));
            }
        }
    }
    
    // Excavate
    let removed = terrain.excavate(&AabbShape(Aabb {
        center: Vec3::new(1.5, 1.5, 1.5),
        half_extents: Vec3::splat(1.5),
    }));
    
    assert!(removed > 0.0);
}

#[test]
fn test_coordinate_conversion() {
    let terrain = VoxelTerrain::default();
    
    let world_pos = Vec3::new(5.0, 3.0, 7.0);
    let (chunk_pos, local) = terrain.world_to_chunk_local(world_pos);
    
    // Verify round-trip
    let chunk_origin = terrain.chunk_to_world(chunk_pos);
    let reconstructed = chunk_origin + local.as_vec3() * terrain.config.voxel_size;
    
    assert!((reconstructed - world_pos).length() < terrain.config.voxel_size);
}
```

### 12.2 Integration Tests

```rust
// tests/plan_tests.rs

use bevy::prelude::*;
use bevy_earthworks::prelude::*;

#[test]
fn test_plan_loading() {
    let json = include_str!("fixtures/simple_plan.json");
    let plan: ExecutionPlan = serde_json::from_str(json).unwrap();
    
    assert_eq!(plan.version, "1.0");
    assert!(!plan.steps.is_empty());
    assert!(plan.results.valid);
}

#[test]
fn test_full_playback() {
    // Create minimal Bevy app
    let mut app = App::new();
    app.add_plugins(MinimalPlugins)
       .add_plugins(EarthworksPlugin::default());
    
    // Load test plan
    // ... 
    
    // Advance time and verify state
    for _ in 0..100 {
        app.update();
    }
    
    // Check final state
    let score = app.world().resource::<SimulationScore>();
    assert!(score.total_cost > 0.0);
}
```

### 12.3 Visual Tests

```rust
// examples/visual_test.rs

//! Run with: cargo run --example visual_test
//! Displays test patterns for visual verification

use bevy::prelude::*;
use bevy_earthworks::prelude::*;

fn main() {
    App::new()
        .add_plugins(DefaultPlugins)
        .add_plugins(EarthworksPlugin {
            config: EarthworksConfig {
                enable_debug_visuals: true,
                ..default()
            },
        })
        .add_systems(Startup, setup_test_scene)
        .run();
}

fn setup_test_scene(mut terrain: ResMut<VoxelTerrain>, mut commands: Commands) {
    // Create checkerboard terrain for visual verification
    for x in 0..20 {
        for z in 0..20 {
            let material = if (x + z) % 2 == 0 {
                MaterialId::Dirt
            } else {
                MaterialId::Clay
            };
            
            for y in 0..5 {
                terrain.set_voxel(
                    Vec3::new(x as f32 * 0.3, y as f32 * 0.3, z as f32 * 0.3),
                    Voxel::solid(material),
                );
            }
        }
    }
    
    // Spawn test excavator
    commands.spawn(presets::cat_320());
    
    // Camera
    commands.spawn((
        Camera3d::default(),
        Transform::from_xyz(10.0, 10.0, 10.0).looking_at(Vec3::ZERO, Vec3::Y),
    ));
}
```

---

## 13. Implementation Roadmap

### Phase 1: Core Foundation (Days 1-2)

| Task | Priority | Estimated Time |
|------|----------|----------------|
| Project setup (Cargo.toml, module structure) | P0 | 2h |
| Voxel and Chunk data structures | P0 | 4h |
| Basic terrain operations (set/get voxel) | P0 | 3h |
| Coordinate conversion utilities | P0 | 2h |
| Simple cube mesh generation | P0 | 3h |
| Basic Bevy plugin structure | P0 | 2h |

**Deliverable:** Render a manually-created voxel terrain

### Phase 2: Plan Loading (Days 3-4)

| Task | Priority | Estimated Time |
|------|----------|----------------|
| Plan JSON schema (Rust types) | P0 | 3h |
| Asset loader implementation | P0 | 4h |
| Terrain decoding (RLE) | P0 | 2h |
| Initialize terrain from plan | P0 | 3h |
| Machine spawning from plan | P0 | 3h |
| Basic playback state | P0 | 2h |

**Deliverable:** Load and display a TerraFirma.jl plan

### Phase 3: Playback System (Days 5-6)

| Task | Priority | Estimated Time |
|------|----------|----------------|
| Plan executor system | P0 | 4h |
| Terrain modification (excavate/fill) | P0 | 4h |
| Machine animation (position interpolation) | P1 | 3h |
| Timeline UI (egui) | P1 | 4h |
| Keyboard controls | P1 | 2h |

**Deliverable:** Play back a plan with terrain changes and machine movement

### Phase 4: Greedy Meshing (Day 7)

| Task | Priority | Estimated Time |
|------|----------|----------------|
| Greedy mesh algorithm | P0 | 6h |
| Face merging by material | P1 | 2h |
| Chunk dirty tracking | P0 | 2h |
| Incremental mesh updates | P1 | 3h |

**Deliverable:** Efficient terrain rendering with greedy meshing

### Phase 5: Visual Polish (Days 8-9)

| Task | Priority | Estimated Time |
|------|----------|----------------|
| Machine gizmos (work envelopes) | P1 | 4h |
| Score overlay UI | P1 | 3h |
| Camera system (orbit, follow) | P1 | 4h |
| Material colors and shading | P2 | 2h |
| Particle effects (dust) | P2 | 4h |

**Deliverable:** Polished visualization ready for demo

### Phase 6: Testing & Documentation (Days 10-11)

| Task | Priority | Estimated Time |
|------|----------|----------------|
| Unit tests | P1 | 4h |
| Integration tests | P1 | 3h |
| Example applications | P1 | 4h |
| API documentation | P1 | 3h |
| README and usage guide | P0 | 3h |

**Deliverable:** Production-ready plugin with documentation

### Phase 7: Stretch Goals (Days 12-14)

| Task | Priority | Estimated Time |
|------|----------|----------------|
| Video export (frame capture) | P2 | 6h |
| LOD system | P2 | 8h |
| GLTF machine models | P2 | 4h |
| Audio cues | P3 | 4h |

**Deliverable:** Enhanced features for TerraFirma demo

---

## 14. Success Criteria

### 14.1 Functional Requirements

| Requirement | Verification |
|-------------|--------------|
| Load plan JSON from TerraFirma.jl | Plan loads without errors |
| Display initial terrain correctly | Visual match to expected |
| Execute all plan step types | MoveTo, Excavate, Dump, Idle work |
| Terrain updates match plan | Dirt appears/disappears correctly |
| Playback controls work | Play, pause, seek, speed all functional |
| Score display matches plan | Values within 1% of expected |

### 14.2 Performance Requirements

| Requirement | Target | Test |
|-------------|--------|------|
| 60 FPS sustained | ≥ 60 FPS | Profile with 80×80×8 terrain |
| Load time | < 2s | Measure from app start to interactive |
| Memory usage | < 500MB | Monitor during full playback |
| No frame drops during playback | 0 drops | Visual inspection |

### 14.3 Quality Requirements

| Requirement | Verification |
|-------------|--------------|
| No crashes during normal use | 1 hour soak test |
| Handles malformed plans gracefully | Error message, no crash |
| All public APIs documented | Doc coverage check |
| Examples compile and run | CI verification |
| Tests pass | `cargo test` succeeds |

### 14.4 Brownfield Challenge Requirements

| Requirement | Evidence |
|-------------|----------|
| Fork of substantial repo | bevy (37k+ stars) |
| New language learned | Rust code quality |
| Non-trivial feature | LOC count, feature scope |
| Production quality | Tests, docs, examples |
| Clear commit history | Git log |

---

## 15. Appendices

### 15.1 Glossary

| Term | Definition |
|------|------------|
| Voxel | Volumetric pixel; a 3D unit of terrain |
| Chunk | 16×16×16 group of voxels |
| Greedy Meshing | Algorithm to merge adjacent faces into larger quads |
| Work Envelope | 3D region a machine can reach |
| Toroidal | Donut-shaped; describes excavator reach |
| Plan | Sequence of actions for machines to execute |
| Step | Single action at a specific timestamp |
| Playback | Executing a plan over time |

### 15.2 References

- [Bevy Book](https://bevyengine.org/learn/book/introduction/)
- [Bevy ECS Documentation](https://docs.rs/bevy_ecs/)
- [Greedy Meshing Article](https://0fps.net/2012/06/30/meshing-in-a-minecraft-game/)
- [TerraFirma.jl PRD](./terrafirma_jl_prd.md)
- [Plan JSON Schema](./plan_schema.md)

### 15.3 File Format Examples

See `examples/fixtures/` for sample plan JSON files.

### 15.4 Keyboard Shortcuts Reference

| Key | Action |
|-----|--------|
| `Space` | Play/Pause |
| `R` | Reset to start |
| `[` | Halve speed |
| `]` | Double speed |
| `G` | Toggle grid |
| `E` | Toggle envelopes |
| `C` | Cycle camera mode |
| `F11` | Toggle fullscreen |
| `Escape` | Quit |

---

*End of PRD*

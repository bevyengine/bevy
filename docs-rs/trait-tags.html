<script>
    // Adds tags to documentation pages for common Bevy traits like `Component` or `Resource`.
    // This makes it easier to see at a glance what types are used for.
    //
    // This extension is passed to `rustdoc` using the `--html-after-content` flag.

    // Traits that we want to show as tags.
    // Order determines order sections, as well as order of tags if multiple are implemented.
    const bevyTraits = [
        'Plugin',
        'PluginGroup',
        'Component',
        'Resource',
        'Asset',
        'Event',
        'ScheduleLabel',
        'SystemSet',
        'SystemParam',
        'Relationship',
        'RelationshipTarget'
    ];

    // Find all traits that are implemented by the current type.
    const implementedBevyTraits = findImplementedBevyTraits(document);

    // If we found any implemented traits, add them as tags to the top of the page.
    if (implementedBevyTraits.size > 0) {
        // Create a container for the tags.
        const heading = document.body.querySelector(".main-heading h1");
        const tagContainer = document.createElement('div');
        tagContainer.className = 'bevy-tag-container';
        heading.appendChild(tagContainer);

        // Check if an implemented trait has a `type Mutability = Immutable` associated type.
        // This is used to determine if a `Component` is immutable or not.
        // TODO: Ideally we should just check the associated types of the `Component` trait,
        //       but the docs.rs layout makes it tricky to do so in a robust way.
        const associatedTypeHeader = document.querySelectorAll(".trait-impl.associatedtype .code-header");
        const isImmutable = [...associatedTypeHeader].some(el => el.innerText.includes('type Mutability = Immutable'));

        // Create a tag for each implemented trait.
        for (let [tagName, href] of implementedBevyTraits) {
            if (tagName == 'Component' & isImmutable) {
                tagName = 'Immutable Component';
            }

            // Create the tag and append it to the container.
            tagContainer.appendChild(createBevyTag(tagName, href));
        }
    }

    function findImplementedBevyTraits(doc) {
        // Traits that are implemented by the current type.
        // The key is the trait name, and the value is the href to the trait's documentation.
        const implementedTraits = new Map();

        // Find all trait implementation headers.
        const allTraitHeaders = doc.body.querySelectorAll(
            '#trait-implementations-list .impl .code-header, #blanket-implementations-list .impl .code-header'
        );

        for (const header of allTraitHeaders) {
            // We can extract the trait name by removing any generics and splitting the string by spaces.
            // This results in ['impl', 'TraitName', 'for', 'TypeName'].
            const traitName = removeGenerics(header.innerText).split(' ')[1].trim();

            // Find the link to the trait if the anchor element exists.
            // Otherwise, the trait is just in plain text.
            const traitLinkEl = [...header.children].find(el => el.getAttribute('href')?.includes(`trait.${traitName}.html`));
            const href = traitLinkEl?.getAttribute('href');

            implementedTraits.set(traitName, href);
        }

        const implementedBevyTraits = new Map(
            [...implementedTraits].filter(([traitName, _]) => bevyTraits.find((x) => x == traitName))
        );

        // Every `Event` also implements `Component`, but it is extremely rare
        // to actually use events as components, so we skip the component tag for them.
        if (implementedBevyTraits.has('Event')) {
            implementedBevyTraits.delete('Component')
        }

        return implementedBevyTraits;
    }

    // Helper function to remove generics from a string of Rust code.
    // For example, 'Vec<T>' would become 'Vec'.
    function removeGenerics(str) {
        // Remove the innermost generics.
        const newStr = str.replace(/<([^<>])*>/g, '');

        // If there are still generics, perform the removal again recursively.
        if (newStr !== str) {
            return removeGenerics(newStr);
        }

        // No more generics to remove.
        return newStr;
    }

    // Helper function to create a tag element with the given name and href,
    // if available.
    function createBevyTag(tagName, href) {
        const el = document.createElement('a');
        const kebabCaseName = tagName.toLowerCase().replace(' ', '-');

        if (href) {
            el.setAttribute('href', href);
        }

        el.innerText = tagName;
        el.className = `bevy-tag ${kebabCaseName}-tag`;
        return el;
    }

    const info_node = document.getElementById("bevy-traits-data");

    if (info_node) {
        const info = JSON.parse(info_node.innerText);

        // Make sure sections are in the right order
        for (const trait of bevyTraits) {
            findOrCreateListing(trait + "s")
        }

        for (const item of findItems()) {
            const traits = info[itemName(item)];
            if (!traits) {
                continue
            }
            const description = item.nextSibling;

            // If item implements multiple Bevy traits, it gets
            // added to multiple listings
            for (const trait of traits) {
                const listing = findOrCreateListing(trait + "s");
                listing.appendChild(item.cloneNode(true));
                if (description && description.nodeName == "DD") {
                    listing.appendChild(description.cloneNode(true))
                }
            }

            item.remove()
            if (description) {
                description.remove()
            }
        }

        removeEmptySections();
    }

    // Collect and sort items that may implement Bevy traits
    function findItems() {
        const items = [];
        for (const kind of ['structs', 'enums', 'unions', 'functions']) {
            // Find the listing
            const header = document.getElementById(kind);
            if (!header) {
                continue
            }
            const listing = header.nextSibling;

            for (const item of listing.children) {
                // Only look at items, not their description
                if (item.nodeName == "DT") {
                    items.push(item);
                }
            }
        }
        // Sort alphabetically as they aren't in order
        items.sort((a, b) => itemName(a).localeCompare(itemName(b)));
        return items
    }

    // Given an item of a listing, returns its name
    function itemName(item) {
        let url = item.firstChild.href;
        let name_end = url.lastIndexOf(".");
        let name_start = url.lastIndexOf(".", name_end - 1) + 1;
        return url.substring(name_start, name_end);
    }

    // Requires there to be a structs, enums, unions or functions listing
    function findOrCreateListing(tagName) {
        // Try to find the listing
        let header = document.getElementById(kebabCase(tagName));
        if (header) {
            return header.nextSibling;
        }

        // Insert the new heading between Modules and Structs
        let next_header;
        for (const kind of ['functions', 'unions', 'enums', 'structs']) {
            next_header = document.getElementById(kind);
        }

        // Create new listing
        const listing = document.createElement('dl');
        next_header.before(listing);
        listing.className = 'item-table';

        header = document.createElement('h2');
        listing.before(header);
        header.id = kebabCase(tagName);
        header.className = 'section-header'
        header.innerText = tagName;

        const anchor = document.createElement('a');
        header.appendChild(anchor);
        anchor.className = 'anchor';
        anchor.href = '#' + kebabCase(tagName);
        anchor.innerText = 'ยง';

        return listing;
    }

    function kebabCase(tagName) {
        return tagName.toLowerCase().replace(' ', '-');
    }

    function removeEmptySections() {
        let toRemove = []
        for (const header of document.getElementsByClassName('section-header')) {
            const listing = header.nextSibling;
            if (listing.nodeName == "DL" & listing.childElementCount == 0) {
                toRemove.push(header);
                toRemove.push(listing);
            }
        }
        for (const elem of toRemove) {
            elem.remove()
        }
    }
</script>

<style>
    .bevy-tag-container {
        padding: 0.5rem 0;
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem;
    }

    .bevy-tag {
        display: flex;
        align-items: center;
        width: fit-content;
        height: 1.5rem;
        padding: 0 0.5rem;
        border-radius: 0.75rem;
        font-size: 1rem;
        font-weight: normal;
        color: white;
        background-color: var(--tag-color);
    }

    .component-tag,
    .immutable-component-tag {
        --tag-color: oklch(50% 27% 95);
    }

    .resource-tag {
        --tag-color: oklch(50% 27% 110);
    }

    .asset-tag {
        --tag-color: oklch(50% 27% 0);
    }

    .event-tag {
        --tag-color: oklch(50% 27% 310);
    }

    .plugin-tag,
    .plugingroup-tag {
        --tag-color: oklch(50% 27% 50);
    }

    .schedulelabel-tag,
    .systemset-tag {
        --tag-color: oklch(50% 27% 270);
    }

    .systemparam-tag {
        --tag-color: oklch(50% 27% 200);
    }

    .relationship-tag,
    .relationshiptarget-tag {
        --tag-color: oklch(50% 27% 150);
    }
</style>